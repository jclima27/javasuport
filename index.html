<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Java QuickRef</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <header>
    <input
      type="text"
      id="filterInput"
      placeholder="Filtrar por palavra-chave..."
    />
  </header>

  <main id="grid">
    <h2 class="section-title">üìò B√°sico</h2>
    <!-- Bloco 1 -->
    <div class="block" data-tags="V√°riaveis">
      <div class="title">V√°riaveis</div>
        <button class="copy-btn">Copiar</button>
      <pre>
<code>
int num = 5;
float floatNum = 5.99f;
char letter = 'D';
boolean bool = true;
String site = "teste";
long idadeLong = 9223372036854775807L;
double peso = 70.5;
</code>
      </pre>
    </div>

    <div class="block wide" data-tags="tipos de dados primitivos">
        <div class="title">Tipos de Dados Primitivos</div>
        <div class="code-container">
          <table>
            <thead>
              <tr>
                <th>Tipo de Dado</th>
                <th>Tamanho</th>
                <th>Valor Default</th>
                <th>Range</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>byte</td>
                <td>8 bits</td>
                <td>0</td>
                <td>-128 a 127</td>
              </tr>
              <tr>
                <td>short</td>
                <td>16 bits</td>
                <td>0</td>
                <td>-32.768 a 32.767</td>
              </tr>
              <tr>
                <td>int</td>
                <td>32 bits</td>
                <td>0</td>
                <td>-2¬≥¬π a 2¬≥¬π-1</td>
              </tr>
              <tr>
                <td>long</td>
                <td>64 bits</td>
                <td>0L</td>
                <td>-2‚Å∂¬≥ a 2‚Å∂¬≥-1</td>
              </tr>
              <tr>
                <td>float</td>
                <td>32 bits</td>
                <td>0.0f</td>
                <td>¬±1.4E-45 a ¬±3.4E+38</td>
              </tr>
              <tr>
                <td>double</td>
                <td>64 bits</td>
                <td>0.0d</td>
                <td>¬±4.9E-324 a ¬±1.8E+308</td>
              </tr>
              <tr>
                <td>char</td>
                <td>16 bits</td>
                <td>'\u0000'</td>
                <td>'\u0000' a '\uffff'</td>
              </tr>
              <tr>
                <td>boolean</td>
                <td>1 bit (representado como 1 byte na pr√°tica)</td>
                <td>false</td>
                <td>true ou false</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

    <!-- Bloco 2 -->
    <div class="block" data-tags="Operadores Aritm√©ticos">
      <div class="title">Operadores Aritm√©ticos</div>
        <button class="copy-btn">Copiar</button>
<pre>
<code>
int a = 10;
int b = 3;

int soma = a + b;  // 13
int subtracao = a - b;  // 7
int multiplicacao = a * b;  // 30
int divisao = a / b;  // 3
int restoDaDivisao = a % b; // 1 
</code>
</pre>
    </div>

    <!-- Bloco 3 -->
    <div class="block" data-tags="Operadores de Atribui√ß√£o">
      <div class="title">Operadores de Atribui√ß√£o</div>
        <button class="copy-btn">Copiar</button>
<pre>
<code>
int x = 5;
x += 2; // x = x + 2
x -= 1; // x = x - 1
x *= 3; // x = x * 3
x /= 2; // x = x / 2
x %= 2; // x = x % 2
</code>
</pre>
    </div>
    
    <!-- Bloco 4 -->
    <div class="block" data-tags="Operadores Relacionais">
        <div class="title">Operadores Relacionais</div>
          <button class="copy-btn">Copiar</button>
<pre>
<code>
int a = 5, b = 10;

System.out.println(a == b); // false
System.out.println(a != b); // true
System.out.println(a > b);  // false
System.out.println(a < b);  // true
System.out.println(a >= b); // false
System.out.println(a <= b); // true
</code>
</pre>
      </div>

    <!-- Bloco 4 -->
    <div class="block" data-tags="Operadores L√≥gicos">
        <div class="title">Operadores L√≥gicos</div>
          <button class="copy-btn">Copiar</button>
<pre>
<code>
boolean cond1 = true;
boolean cond2 = false;

(cond1 && cond2); // false (E l√≥gico)
(cond1 || cond2); // true  (OU l√≥gico)
(!cond1);         // false (nega√ß√£o)
</code>
</pre>
    </div>

    <!-- Bloco 6 -->
    <div class="block" data-tags="Convers√£o Implicita">
        <div class="title">Convers√£o Implicita</div>
          <button class="copy-btn">Copiar</button>
<pre>
<code>
//Casting Implicito
//quando voc√™ est√° convertendo de um tipo 
//menor para um tipo maior, ou seja, 
//quando n√£o h√° risco de perda de dados.

// Convers√£o autom√°tica de int para double
int num = 10;
double valor = num;

</code>
</pre>
    </div>

    <!-- Bloco 6 -->
    <div class="block" data-tags="Convers√£o explicita">
        <div class="title">Convers√£o Explicita</div>
          <button class="copy-btn">Copiar</button>
<pre>
<code>
//Casting Explicito
//√â quando voc√™ precisa informar que
//quer converter, porque existe 
//risco de perder informa√ß√£o.

// Perde a parte decimal (resultado: 10)
double valorDecimal = 10.75;
int valorInteiro = (int) valorDecimal;

</code>
</pre>
    </div>

    <h2 class="section-title">üìò String</h2>

    <!-- Bloco 7 -->
    <div class="block" data-tags="Concatenando Strings">
        <div class="title">Concatenando Strings</div>
        <button class="copy-btn">Copiar</button>
<pre>
<code>
String nome = "Jo√£o";
String sobrenome = "Silva";
String nomeCompleto = nome + " " + sobrenome; // Jo√£o Silva

String concat = nome.concat(" Silva"); // Jo√£o Silva



</code>
</pre>
    </div>

    <!-- Bloco 8 -->
    <div class="block" data-tags="Comparando Strings">
        <div class="title">Comparando Strings</div>
        <button class="copy-btn">Copiar</button>
<pre>
<code>
String str1 = "Java";
String str2 = "java";
boolean iguais = str1.equals(str2); // false

//Compara√ß√£o sem diferenciar min√∫scula de maiuscula
boolean iguaisIgnoreCase = str1.equalsIgnoreCase(str2); // true


</code>
</pre>
    </div>

    <!-- Bloco 9 -->
    <div class="block" data-tags="string manipula√ß√£o texto">
        <div class="title">Substituindo em String</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
String frase = "Eu amo Java";
String novaFrase = frase.replace("Java", "Python"); // Eu amo Python

//remove pontos e tra√ßos
String message = "000-123-4567 or 000.123.4567";
String normalizedMessage = message.replaceAll("[.-]", "");
System.out.println(normalizedMessage);
</code>
        </pre>
    </div>

    
<!-- Bloco: Obtendo comprimento da String -->
    <div class="block" data-tags="string comprimento texto">
        <div class="title">Obtendo Comprimento da String</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
String texto = "Java";
int comprimento = texto.length(); // 4
</code>
        </pre>
    </div>

<!-- Bloco: Extraindo parte da String -->
    <div class="block" data-tags="string substring manipula√ß√£o texto">
        <div class="title">Extraindo Parte da String</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
String frase = "Eu amo programa√ß√£o";
String parte = frase.substring(3, 6); // "amo"
</code>
        </pre>
    </div>

<!-- Bloco: Convertendo para mai√∫sculas ou min√∫sculas -->
    <div class="block" data-tags="string mai√∫scula min√∫scula texto">
        <div class="title">Convertendo para Mai√∫sculas ou Min√∫sculas</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
String texto = "java";
String maiusculo = texto.toUpperCase(); // "JAVA"
String minusculo = texto.toLowerCase(); // "java"
</code>
        </pre>
    </div>

<!-- Bloco: Verificando in√≠cio ou fim da String -->
    <div class="block" data-tags="string startwith endswith texto">
        <div class="title">Verificando In√≠cio ou Fim da String</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
String frase = "Java √© poderoso";
boolean comecaComJava = frase.startsWith("Java"); // true
boolean terminaComPoderoso = frase.endsWith("poderoso"); // true
</code>
        </pre>
    </div>

<!-- Bloco: Removendo espa√ßos em branco -->
    <div class="block" data-tags="string trim espa√ßo texto">
        <div class="title">Removendo Espa√ßos em Branco</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
String frase = "  Ol√°, Mundo!  ";
String limpa = frase.trim(); // "Ol√°, Mundo!"
</code>
        </pre>
    </div>

<!-- Bloco: Dividindo a String -->
    <div class="block" data-tags="string split dividir texto">
        <div class="title">Dividindo a String</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
String frase = "ma√ß√£,banana,laranja";
String[] frutas = frase.split(","); // ["ma√ß√£", "banana", "laranja"]
</code>

        </pre>
    </div>

<!-- Bloco: Verificando se cont√©m uma substring -->
    <div class="block" data-tags="string contains substring texto">
        <div class="title">Verificando se Cont√©m uma Substring</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
String frase = "Eu gosto de Java";
boolean temJava = frase.contains("Java"); // true
</code>

        </pre>
    </div>

<!-- Bloco: Substituindo em Strings -->
    <div class="block" data-tags="string replace manipula√ß√£o texto">
        <div class="title">Verificando se a String esta vazia</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
String frase = "abcd"
frase.isEmpty();      //false
</code>

        </pre>
    </div>

<!-- Bloco: Comparando Strings -->
    <div class="block" data-tags="string compareTo compara√ß√£o texto">
        <div class="title">Comparando Strings</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
String str1 = "Java";
String str2 = "JavaScript";
int resultado = str1.compareTo(str2); // Valor < 0, pois "Java" vem antes de "JavaScript"
</code>
        </pre>
    </div>

    <!-- Bloco: charAt -->
    <div class="block" data-tags="string charAt caractere √≠ndice">
        <div class="title">Obtendo um Caractere com charAt</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
String palavra = "banana";
char letra = palavra.charAt(2); // 'n'
</code>
        </pre>
    </div>
  
  <!-- Bloco: indexOf -->
    <div class="block" data-tags="string indexOf posi√ß√£o encontrar">
        <div class="title">Encontrando Substring com indexOf</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
String texto = "Eu gosto de Java";
int indice = texto.indexOf("Java"); // 12
</code>
        </pre>
    </div>

    <!-- Bloco: Conversao -->
    <div class="block" data-tags="string indexOf posi√ß√£o encontrar">
        <div class="title">Convertendo para String</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
int valor = 12;
String num = String.valueOf(valor); // "12"
</code>
        </pre>
    </div>
    
    <h2 class="section-title">üìò StringBuilder</h2>

    <!-- Bloco: Criando e adicionando texto -->
    <div class="block" data-tags="stringbuilder append criar adicionar">
        <div class="title">Criando e Adicionando Texto</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
StringBuilder sb = new StringBuilder();
sb.append("Ol√°");
sb.append(" Mundo!");
System.out.println(sb.toString()); // Ol√° Mundo!
</code>
        </pre>
    </div>
  
  <!-- Bloco: Inserindo texto -->
    <div class="block" data-tags="stringbuilder insert inserir">
        <div class="title">Inserindo Texto</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
StringBuilder sb = new StringBuilder("Java √© legal");
sb.insert(5, "muito ");
System.out.println(sb.toString()); // Java muito √© legal
</code>

        </pre>
    </div>
  
  <!-- Bloco: Substituindo texto -->
    <div class="block" data-tags="stringbuilder replace substituir">
        <div class="title">Substituindo Texto</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
StringBuilder sb = new StringBuilder("Ol√° Mundo");
sb.replace(4, 9, "Java");
System.out.println(sb.toString()); // Ol√° Java
</code>
    
        </pre>
    </div>
  
  <!-- Bloco: Deletando texto -->
    <div class="block" data-tags="stringbuilder delete deletar remover">
        <div class="title">Removendo Parte do Texto</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
StringBuilder sb = new StringBuilder("Remover isso");
sb.delete(8, 13);
System.out.println(sb.toString()); // Remover
</code>
        </pre>
    </div>
  
  <!-- Bloco: Revertendo texto -->
    <div class="block" data-tags="stringbuilder reverse inverter">
        <div class="title">Invertendo Texto</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
StringBuilder sb = new StringBuilder("abc");
sb.reverse();
System.out.println(sb.toString()); // cba
</code>
        </pre>
    </div>
    
    <h2 class="section-title">üìò Integer</h2>

    <!-- Bloco: Convertendo String para Integer -->
    <div class="block" data-tags="integer parseint converter string inteiro">
      <div class="title">Convertendo String para Integer</div>
      <button class="copy-btn">Copiar</button>
      <pre>
<code>
String valor = "123";
int numero = Integer.parseInt(valor);
System.out.println(numero); // 123
</code>
      </pre>
    </div>

    <!-- Bloco: Convertendo Integer para String -->
    <div class="block" data-tags="integer tostring converter inteiro string">
      <div class="title">Convertendo Integer para String</div>
      <button class="copy-btn">Copiar</button>
      <pre>
<code>
int numero = 456;
String texto = Integer.toString(numero);
System.out.println(texto); // "456"
</code>
      </pre>
    </div>

<!-- Bloco: Comparando inteiros -->
    <div class="block" data-tags="integer compare comparar equals">
      <div class="title">Comparando Inteiros</div>
      <button class="copy-btn">Copiar</button>
      <pre>
<code>
Integer a = 10;
Integer b = 20;

System.out.println(a.equals(b)); // false

// 0 se a for igual a b
// -1 se a for menor que b
// 1 se a for maior que b

System.out.println(Integer.compare(a, b)); // -1
</code>
      </pre>
    </div>

    <!-- Bloco: Convertendo para bin√°rio, octal e hexadecimal -->
    <div class="block" data-tags="integer bin√°rio octal hexadecimal tobinarystring">
      <div class="title">Bin√°rio, Octal e Hexadecimal</div>
      <button class="copy-btn">Copiar</button>
      <pre>
<code>
int numero = 42;

System.out.println(Integer.toBinaryString(numero)); // 101010
System.out.println(Integer.toOctalString(numero));  // 52
System.out.println(Integer.toHexString(numero));    // 2a
</code>
      </pre>
    </div>

    <!-- Bloco: Valor m√°ximo e m√≠nimo -->
    <div class="block" data-tags="integer max min limite valor m√°ximo m√≠nimo">
      <div class="title">Valor M√°ximo e M√≠nimo</div>
      <button class="copy-btn">Copiar</button>
      <pre>
<code>
System.out.println(Integer.MAX_VALUE); // 2147483647
System.out.println(Integer.MIN_VALUE); // -2147483648



</code>
      </pre>
    </div>

    <h2 class="section-title">üìò Double</h2>

<!-- Bloco 1 - Cria√ß√£o e m√©todos b√°sicos -->
    <div class="block" data-tags="double wrapper parsevalue valor toString isNaN isInfinite">
      <div class="title">Double - M√©todos e Opera√ß√µes</div>
      <button class="copy-btn">Copiar</button>
      <pre>
<code>
// Criando objetos Double
Double d1 = 10.5;
Double d2 = Double.valueOf("20.5");

// Compara√ß√µes
// 0 se a for igual a b
// -1 se a for menor que b
// 1 se a for maior que b

System.out.println(Double.compare(d1, d2)); // -1

// Verifica√ß√µes
System.out.println(Double.isNaN(d1));      // false
System.out.println(Double.isInfinite(d1)); // false

// Convers√µes
double valor = d1.doubleValue();         // 10.5
String texto = d1.toString();            // "10.5"
Double d3 = Double.parseDouble("30.25"); // 30.25
</code>
      </pre>
    </div>

<!-- Bloco 2 - Constantes e limites -->
    <div class="block" data-tags="double constante valor maximo minimo positivo infinito negativo">
      <div class="title">Double - Constantes</div>
      <button class="copy-btn">Copiar</button>
      <pre>
<code>
System.out.println(Double.MAX_VALUE);  // Maior valor positivo
System.out.println(Double.MIN_VALUE);  // Menor valor positivo

System.out.println(Double.POSITIVE_INFINITY); // Infinito positivo
System.out.println(Double.NEGATIVE_INFINITY); // Infinito negativo
System.out.println(Double.NaN);              // Not-a-Number
</code>
    </pre>
    </div>

    <h2 class="section-title">üìò BigDecimal</h2>

    <div class="block" data-tags="bigdecimal soma add">
      <div class="title">BigDecimal - Opera√ß√µes</div>
      <pre>
<code>
Soma  
BigDecimal a = new BigDecimal("10.50");
BigDecimal b = new BigDecimal("5.25");
BigDecimal resultado = a.add(b); // 15.75

// Subtra√ß√£o
BigDecimal a = new BigDecimal("10.50");
BigDecimal b = new BigDecimal("5.25");
BigDecimal resultado = a.subtract(b); // 5.25

//Multiplica√ß√£o
BigDecimal preco = new BigDecimal("2.50");
BigDecimal quantidade = new BigDecimal("4");
BigDecimal total = preco.multiply(quantidade); // 10.00

//Divis√£o
<strong>Sempre defina o modo de arredondamento ao dividir.</strong>
import java.math.RoundingMode;
BigDecimal total = new BigDecimal("10");
BigDecimal partes = new BigDecimal("3");
BigDecimal resultado = total.divide(partes, 2, RoundingMode.HALF_UP); // 3.33
</code>


      </pre>
    </div>

    <div class="block" data-tags="bigdecimal comparar compareTo">
      <div class="title">Compara dois BigDecimal</div>
      <pre>
<code>
BigDecimal a = new BigDecimal("10.00");
BigDecimal b = new BigDecimal("10");

// 0 se a for igual a b
// -1 se a for menor que b
// 1 se a for maior que b
if (a.compareTo(b) == 0) {
  System.out.println("S√£o iguais");
}

</code>
      </pre>
      <div class="title">Retorna o maior valor</div>
      <pre>
<code>
BigDecimal a = new BigDecimal("10");
BigDecimal b = new BigDecimal("20");
BigDecimal maior = a.max(b); // 20  
</code>
      </pre>
      <div class="title">Define casas decimais com arredondamento</div>
      <pre>
<code>
BigDecimal valor = new BigDecimal("3.14159");
BigDecimal arredondado = valor.setScale(2, RoundingMode.HALF_UP); // 3.14  
</code>
      </pre>
    </div>

    <div class="block" data-tags="bigdecimal zeros stripTrailingZeros">
      <div class="title">Remove zeros desnecess√°rios</div>
      <pre>
<code>
BigDecimal valor = new BigDecimal("10.000");
valor = valor.stripTrailingZeros(); // 1E+1
</code>
      </pre>
      <div class="title">Exibe o n√∫mero em formato normal</div>
      <pre>
<code>
BigDecimal valor = new BigDecimal("1.00E+2");
valor.toPlainString(); // "100"
</code>
      </pre>
      <div class="title">Retorna o resto da divis√£o</div>
      <pre>
<code>
BigDecimal a = new BigDecimal("10");
BigDecimal b = new BigDecimal("3");
BigDecimal resto = a.remainder(b); // 1
</code>
      </pre>
      <div class="title">Retorna o valor absoluto</div>
      <pre>
<code>
BigDecimal negativo = new BigDecimal("-25.5");
BigDecimal absoluto = negativo.abs(); // 25.5
</code>
      </pre>
    </div>

    <div class="block" data-tags="bigdecimal zeros stripTrailingZeros">
      <div class="title">Retorna o menor valor</div>
      <pre>
<code>
BigDecimal a = new BigDecimal("10");
BigDecimal b = new BigDecimal("20");
BigDecimal menor = a.min(b); // 10
</code>
      </pre>
      <div class="title">Converte para tipos primitivos</div>
      <pre>
<code>
BigDecimal valor = new BigDecimal("123.45");
double d = valor.doubleValue();
int i = valor.intValue(); // 123
Long l = valor.longValue();
</code>
      </pre>
    </div>

    <div class="block" data-tags="bigdecimal zeros stripTrailingZeros">
      <div class="title">Move a v√≠rgula n casas pra esquerda</div>
      <pre>
<code>
BigDecimal valor = new BigDecimal("12345");
valor = valor.movePointLeft(2); // 123.45  
</code>
      </pre>
    </div>

    <div class="block" data-tags="bigdecimal zeros stripTrailingZeros">
      <div class="title">Move a v√≠rgula n casas pra direita</div>
      <pre>
<code>
BigDecimal valor = new BigDecimal("123.45");
valor = valor.movePointRight(2); // 12345    
</code>
      </pre>
    </div>

    <h2 class="section-title">Datas com java.time (Java 8+)</h2>

    <div class="block" data-tags="java.time">
      <div class="title">Trabalhando com datas - LocalDate</div>
      <pre>
<code>
<strong>Retorna a data atual sem hora.</strong>
LocalDate.now() //2025-04-17

<strong>Converte uma string padr√£o ISO para uma data.</strong>
LocalDate.parse("2025-04-13") //2025-04-13

<strong>Cria uma data com ano, m√™s e dia.</strong>
LocalDate.of(2025, 4, 13) //2025-04-13

<strong>Formata uma data com padr√£o personalizado.</strong>
LocalDate
  .format(
    DateTimeFormatter.ofPattern("dd/MM/yyyy"))

<strong>Converte uma string para LocalDate 
  com um padr√£o personalizado.</strong>
LocalDate
  .parse(
    "13/04/2025", 
    DateTimeFormatter.ofPattern("dd/MM/yyyy"))

</code>
      </pre>
    </div>

    <div class="block" data-tags="java.time">
      <div class="title">Trabalhando com datas - LocalDate</div>
      <pre>
<code>
LocalDate hoje = LocalDate.now(); // data atual
<strong>Soma 7 dias √† data.</strong>
LocalDate daquiASeteDias = hoje.plusDays(7);

<strong>Subtrai 7 dias √† data.</strong>
LocalDate SeteDiasAtras = hoje.minusDays(7);  

<strong>Adiciona 1 m√™s √† data.</strong>
LocalDate daquiUmMes = hoje.plusMonths(1);

<strong>Subtrai 1 m√™s da data atual</strong>
LocalDate haUmMesAtras = hoje.minusMonths(1);
</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.time">
      <div class="title">Trabalhando com datas - LocalDate</div>
      <pre>
<code>
// data atual  
LocalDate hoje = LocalDate.now();  
<strong>Adiciona 1 semana √† data atual</strong>
LocalDate daquiUmaSemana = hoje.plusWeeks(1);

<strong>Subtrai 1 semana da data atual</strong>
LocalDate umaSemanaAtras = hoje.minusWeeks(1);

<strong>Adiciona 1 ano √† data atual</strong>
LocalDate daqui1Ano = hoje.plusYears(1);  
</code>
      </pre>
    </div>

    <div class="block" data-tags="java.time">
      <div class="title">Trabalhando com datas - LocalDate</div>
      <pre>
<code>
<strong>Adiciona 1 ano √† data atual</strong>
LocalDate ha1AnoAtras = hoje.minusYears(1);

<strong>Altera o dia de uma data</strong>
LocalDate setDia = hoje.withDayOfMonth(1);

<strong>Altera o m√™s de uma data</strong>
LocalDate setaMes = hoje.withMonth(1);

<strong>Altera o ano de uma data</strong>
LocalDate setAno = hoje.withYear(1);

<strong>Altera uma data de acordo com o dia do ano</strong>
LocalDate setDiaAno = hoje.withDayOfYear(90);
</code>
      </pre>
    </div>

    <div class="block" data-tags="java.time">
      <div class="title">Trabalhando com datas - LocalDate</div>
      <pre>
<code>
<strong>Converte LocalDate para LocalDatetime e 
  adiciona o minuto e segundo como 0</strong>

  // 2025-04-13T00:00
LocalDateTime dataHora = data.atStartOfDay();

<strong>Setar uma hora especifica em um LocalDate</strong>
// 15:30 (3:30 da tarde)
LocalDateTime dataHora = data.atTime(15, 30);

<strong>Jeitos de comparar datas com LocalDate</strong>
LocalDate data1 = LocalDate.of(2025, 4, 13);
LocalDate data2 = LocalDate.of(2025, 4, 10);

//Retorna 0 se valor1 √© igual a valor2
//Retorna > 0 se valor1 √© maior que valor2
//Retorna < 0 se valor1 √© menor que valor2
int resultado = data1.compareTo(data2);  
</code>
       </pre>
    </div>

    <div class="block" data-tags="java.time">
      <div class="title">Trabalhando com datas - LocalDate</div>
      <pre>
<code>
<strong>Retorna todas as datas entre as informadas</strong>
LocalDate start = LocalDate.of(2025, 4, 1);
LocalDate end = LocalDate.of(2025, 4, 5);

start
  .datesUntil(end)
  .forEach(System.out::println);

<strong>Verificar se uma data vem ap√≥s a outra</strong>
LocalDate hoje = LocalDate.now();
LocalDate ontem = hoje.minusDays(1);

hoje.isAfter(ontem); // true
ontem.isAfter(hoje); // false

<strong>Verificar se uma data vem antes da outra</strong>
LocalDate hoje = LocalDate.now();
LocalDate ontem = hoje.minusDays(1);

hoje.isBefore(ontem); // false
ontem.isBefore(hoje); // true

<strong>Verificar se uma data √© igual a outra</strong>
hoje.isEqual(hoje); //true

</code>
       </pre>
    </div>

    <div class="block" data-tags="java.time">
      <div class="title">Per√≠odo entre datas</div>
      <pre>
<code>
LocalDate inicio = LocalDate.of(2024, 1, 1);
LocalDate fim = LocalDate.of(2025, 4, 13);

Period periodo = Period.between(inicio, fim);
System.out.println(periodo.getYears());   // 1
System.out.println(periodo.getMonths());  // 3
System.out.println(periodo.getDays());    // 12
</code>
      </pre>
    </div>

    <div class="block" data-tags="java.time">
      <div class="title">Dura√ß√£o</div>
      <pre>
<code>
LocalDateTime inicio = LocalDateTime.of(2024, 4, 12, 14, 0);
LocalDateTime fim = LocalDateTime.of(2024, 4, 13, 18, 30);
  
Duration duracao = Duration.between(inicio, fim);
System.out.println(duracao.toHours());   // 28
System.out.println(duracao.toMinutes()); // 1710
System.out.println(duracao.getSeconds());// 102600
</code>
      </pre>
    </div>

    <div class="block" data-tags="java.time">
      <div class="title">Per√≠odo entre datas</div>
      <pre>
<code>
LocalDate inicio = LocalDate.of(2023, 10, 1);
LocalDate fim = LocalDate.of(2025, 4, 13);

long dias = ChronoUnit.DAYS.between(inicio, fim);
long meses = ChronoUnit.MONTHS.between(inicio, fim);
long anos = ChronoUnit.YEARS.between(inicio, fim);

System.out.println("Dias: " + dias);
System.out.println("Meses: " + meses);
System.out.println("Anos: " + anos);
</code>
      </pre>
    </div>

    <div class="block" data-tags="java.time">
      <div class="title">Trabalhando com fuso hor√°rio</div>
      <pre>
<code>
<strong>Use ZonedDateTime se quiser manter a no√ß√£o 
de fuso com regi√£o (ex: "America/Sao_Paulo").</strong>  

ZonedDateTime agoraSP = ZonedDateTime
  .now(ZoneId.of("America/Sao_Paulo"));

<strong>Use OffsetDateTime se quiser apenas 
o deslocamento (ex: "-03:00").</strong>

OffsetDateTime agoraOffset = OffsetDateTime
  .now(ZoneOffset.of("-03:00"));

<strong>Instant representa um ponto no tempo 
UTC (sem fuso). Ideal para salvar 
em banco de dados  
</strong>
Instant agora = Instant.now();

// Converter para exibi√ß√£o no fuso do usu√°rio
ZonedDateTime dataLocal = agora
  .atZone(ZoneId.of("America/Sao_Paulo"));

</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.time">
      <div class="title">ZonedDateTime - Convers√£o para outras classes</div>
      <pre>
<code>
ZonedDateTime agora = ZonedDateTime
  .now(ZoneId.of("America/Sao_Paulo"));  

// Para salvar em banco como UTC
Instant instant = agora.toInstant();

// S√≥ a data
LocalDate local = agora.toLocalDate();

// S√≥ a hora
LocalTime hora = agora.toLocalTime();

ZoneOffset offset = agora.getOffset();
</code>
      </pre>
    </div>

    <div class="block" data-tags="java.time">
      <div class="title">OffsetDateTime - Convers√£o para outras classes</div>
      <pre>
<code>
OffsetDateTime agora = OffsetDateTime.now();  

// De ZonedDateTime para OffsetDateTime
ZonedDateTime zdt = ZonedDateTime
  .now(ZoneId.of("America/Sao_Paulo"));

  OffsetDateTime odt = zdt.toOffsetDateTime();

// De LocalDateTime com offset
LocalDateTime ldt = LocalDateTime.now();

OffsetDateTime odt2 = ldt
  .atOffset(ZoneOffset.of("-03:00"));
</code>
      </pre>
    </div>
      
    <h2 class="section-title">üìò Arrays</h2>  

    <div class="block wide" data-tags="tipos de dados primitivos">
      <div class="title">Pilhas, Filas e Collections</div>
      <div class="code-container">
        <table>
          <thead>
            <tr>
              <th>Tipo</th>
              <th>Interface Base</th>
              <th>Vantagens</th>
              <th>Desvantagens</th>
              <th>Quando Usar</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>List</td>
              <td>ArrayList</td>
              <td>Ordem de inser√ß√£o, acesso por √≠ndice, permite duplicados</td>
              <td>R√°pido para leitura</td>
              <td>Lento para inser√ß√µes/remo√ß√µes no meio</td>
            </tr>
            <tr>
              <td>List</td>
              <td>LinkedList</td>
              <td>Lista duplamente ligada</td>
              <td>R√°pido para inser√ß√µes/remo√ß√µes</td>
              <td>Mais lenta para acesso aleat√≥rio</td>
            </tr>
        
            <!-- STACK -->
            <tr>
              <td>Stack</td>
              <td>Stack</td>
              <td>Pilha (LIFO)</td>
              <td>Ideal para algoritmos recursivos</td>
              <td>Baseada em vetor, performance pode variar</td>
            </tr>
            <tr>
              <td>Stack</td>
              <td>Deque como pilha (ArrayDeque)</td>
              <td>Melhor alternativa moderna</td>
              <td>Mais r√°pido que Stack</td>
              <td>Sem sincroniza√ß√£o</td>
            </tr>
        
            <!-- QUEUE -->
            <tr>
              <td>Queue</td>
              <td>LinkedList</td>
              <td>Fila (FIFO), permite nulo</td>
              <td>Simples e vers√°til</td>
              <td>N√£o especializada</td>
            </tr>
            <tr>
              <td>Queue</td>
              <td>ArrayDeque</td>
              <td>Fila sem sincroniza√ß√£o</td>
              <td>Alta performance</td>
              <td>N√£o permite elementos nulos</td>
            </tr>
            <tr>
              <td>Queue</td>
              <td>PriorityQueue</td>
              <td>Ordena por prioridade</td>
              <td>√ìtimo para algoritmos</td>
              <td>Sem ordem previs√≠vel de inser√ß√£o</td>
            </tr>
            <tr>
              <td>Queue</td>
              <td>ConcurrentLinkedQueue</td>
              <td>Fila n√£o bloqueante (concorrente)</td>
              <td>Thread-safe</td>
              <td>Uso avan√ßado</td>
            </tr>
        
            <!-- SET -->
            <tr>
              <td>Set</td>
              <td>HashSet</td>
              <td>Sem ordem, sem duplicados</td>
              <td>Alta performance</td>
              <td>Ordem imprevis√≠vel</td>
            </tr>
            <tr>
              <td>Set</td>
              <td>LinkedHashSet</td>
              <td>Ordem de inser√ß√£o, sem duplicados</td>
              <td>Previsibilidade</td>
              <td>Mais lento que HashSet</td>
            </tr>
            <tr>
              <td>Set</td>
              <td>TreeSet</td>
              <td>Ordenado, sem duplicados</td>
              <td>Ordena√ß√£o natural ou personalizada</td>
              <td>Mais lento</td>
            </tr>
            <tr>
              <td>Set</td>
              <td>EnumSet</td>
              <td>Especializado para enums</td>
              <td>Leve e eficiente</td>
              <td>Somente enums</td>
            </tr>
        
            <!-- MAP -->
            <tr>
              <td>Map</td>
              <td>HashMap</td>
              <td>Chave-valor, sem ordem</td>
              <td>Alta performance</td>
              <td>Sem ordem previs√≠vel</td>
            </tr>
            <tr>
              <td>Map</td>
              <td>LinkedHashMap</td>
              <td>Chave-valor, ordem de inser√ß√£o</td>
              <td>Boa previsibilidade</td>
              <td>Mais lento</td>
            </tr>
            <tr>
              <td>Map</td>
              <td>TreeMap</td>
              <td>Chave-valor ordenado</td>
              <td>Ordena√ß√£o por chave</td>
              <td>Mais pesado</td>
            </tr>
            <tr>
              <td>Map</td>
              <td>EnumMap</td>
              <td>Chave do tipo enum</td>
              <td>Leve e r√°pido</td>
              <td>Somente enums</td>
            </tr>
            <tr>
              <td>Map</td>
              <td>ConcurrentHashMap</td>
              <td>Thread-safe</td>
              <td>Concorr√™ncia sem bloqueio</td>
              <td>Uso mais complexo</td>
            </tr>
        
            <!-- OUTROS -->
            <tr>
              <td>Outros</td>
              <td>Collections.synchronizedList</td>
              <td>Lista sincronizada</td>
              <td>Thread-safe</td>
              <td>Mais lenta</td>
            </tr>
            <tr>
              <td>Outros</td>
              <td>Collections.unmodifiableList</td>
              <td>Lista imut√°vel</td>
              <td>Seguran√ßa em APIs p√∫blicas</td>
              <td>N√£o pode ser alterada</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>  

    <div class="block" data-tags="java.time">
      <div class="title">ArrayList</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Acesso r√°pido por √≠ndice
- Boa performance para leitura sequencial
- Permite duplicatas e elementos null

<strong>Desvantagens</strong>
- Inser√ß√£o/remo√ß√£o lenta no in√≠cio ou meio da lista
- Redimensionamento pode ser custoso
- N√£o √© thread-safe
- Capacidade predefinida pode causar desperd√≠cio

ArrayList<String> nomes = new ArrayList<>();

<strong>Adicionando elementos</strong>
nomes.add("Ana");
nomes.add("Carlos");
// Inserindo "Laranja" na posi√ß√£o 2
nomes.add(2, "Laranja");

<strong>Outra forma de inicializar</strong>
List<String> lista = new ArrayList<>(
  List.of("Ma√ß√£", "Banana", "Laranja"));


<strong>Acessando por √≠ndice</strong>
System.out.println(nomes.get(1)); // Carlos

<strong>Retorna o √≠ndice</strong>
// 1, se n√£o existir retorna -1
System.out.println(lista.indexOf("Carlos"));

<strong>Retorna o √≠ndice da √∫ltima 
ocorr√™ncia</strong>
System.out.println(lista.lastIndexOf("A"));

<strong>Tamanho da lista</strong>
System.out.println(nomes.size()); // 3

<strong>Remover por √≠ndice ou valor</strong>
nomes.remove(0); // Remove "Ana" (√≠ndice 0)
nomes.remove("Carlos");

<strong>Substituindo o elemento no √≠ndice 1</strong>
nomes.set(1, "Julio");

<strong>Retorna uma sublista da lista original</strong>
List<String> sublista = lista.subList(2, 3);
System.out.println(sublista); // [Carlos, Laranja]

<strong>Verificar se cont√©m um elemento</strong>
if (nomes.contains("Ana")) {
    System.out.println("Ana est√° na lista.");
}

<strong>Iterar</strong>
for (String nome : nomes) {
    System.out.println(nome);
}

<strong>Limpa a lista</strong>
nomes.clear();

<strong>Verificar se a lista esta vazia</strong>

System.out.println(nomes.isEmpty()); //true
</code>
      </pre>
    </div>

    <div class="block" data-tags="java.time">
      <div class="title">LinkedList</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Inser√ß√µes e remo√ß√µes eficientes
- Implementa v√°rias interfaces List, Deque (fila dupla), e Queue
- Permite elementos duplicados e nulos

<strong>Desvantagens</strong>
- Acesso aleat√≥rio lento 
- Maior consumo de mem√≥ria
- Em opera√ß√µes que iteram muitos elementos sequencialmente, 
ArrayList tende a ser mais r√°pido por usar um array cont√≠nuo
- N√£o √© thread-safe

LinkedList<String> nomes = new LinkedList<>();

<strong>Adicionando elementos</strong>
nomes.add("Ana");
nomes.add("Carlos");
nomes.addFirst("Jo√£o"); // Adiciona no in√≠cio da lista
nomes.addLast("Maria"); // Adiciona no final da lista

<strong>Outra forma de inicializar</strong>
List<String> lista = new LinkedList<>(
  List.of("Ma√ß√£", "Banana", "Laranja"));

<strong>Cria uma sublista dos elementos de 
√≠ndice 1 at√© 3 (n√£o inclui o 4)</strong>

List<String> sublista = nomes.subList(1, 4);
System.out.println(sublista); // [Carlos, Jo√£o, Maria]  

<strong>Acessando por √≠ndice</strong>
System.out.println(nomes.get(1)); // Carlos

<strong>Remover elementos</strong>
nomes.remove(0); // Remove "Jo√£o" (√≠ndice 0)
nomes.removeFirst(); // Remove o primeiro elemento
nomes.removeLast(); // Remove o √∫ltimo elemento

<strong>Substituindo o elemento no √≠ndice 1</strong>
nomes.set(1, "Julio");

<strong>Verificar se cont√©m um elemento</strong>
if (nomes.contains("Carlos")) {
    System.out.println("Carlos est√° na lista.");
}

<strong>Iterar</strong>
for (String nome : nomes) {
    System.out.println(nome);
}

<strong>Limpa a lista</strong>
nomes.clear();

<strong>Verificar se a lista est√° vazia</strong>
System.out.println(nomes.isEmpty()); //true

<strong>Adicionar um elemento na frente ou no final</strong>
nomes.addFirst("Novo Primeiro");
nomes.addLast("Novo √öltimo");

<strong>Retornar o primeiro e √∫ltimo elemento</strong>
System.out.println("Primeiro: " + nomes.getFirst());
System.out.println("√öltimo: " + nomes.getLast());
</code>
      </pre>
    </div>

    <div class="block" data-tags="java.time">
      <div class="title">Stack</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Herdando de Vector, todos os m√©todos p√∫blicos s√£o sincronizados. 
Pode ser √∫til em ambientes multithreaded simples.
- Inclui m√©todos de busca

<strong>Desvantagens</strong>  
- Internamente usa Vector, que √© considerado antiquado e 
menos eficiente que estruturas mais modernas, como ArrayDeque.
- Por causa da sincroniza√ß√£o e da heran√ßa de Vector, o Stack 
tem desempenho inferior ao ArrayDeque em contextos de thread √∫nica.
- Usado apenas como pilha; n√£o funciona bem como fila ou deque

Stack<String> pilha = new Stack<>();

<strong>Empilhando elementos</strong>
pilha.push("Ana");
pilha.push("Carlos");
pilha.push("Jo√£o");

<strong>Buscar a posi√ß√£o de um elemento</strong>
System.out.println(pilha.search("Carlos")); // 1 

<strong>Verificando o elemento no topo da pilha</strong>
System.out.println(pilha.peek()); // Jo√£o

<strong>Remover o elemento do topo da pilha</strong>
System.out.println(pilha.pop()); // Jo√£o (removido)
System.out.println(pilha.pop()); // Carlos (removido)

<strong>Verificando se a pilha est√° vazia</strong>
System.out.println(pilha.isEmpty()); // false

<strong>Verificando o tamanho da pilha</strong>
System.out.println(pilha.size()); // 1

<strong>Empilhar mais um elemento</strong>
pilha.push("Maria");

<strong>Verificando se a pilha cont√©m um elemento</strong>
System.out.println(pilha.contains("Ana")); // false

<strong>Iterando sobre os elementos da pilha</strong>
for (String nome : pilha) {
    System.out.println(nome);
}

// Sa√≠da:
// Ana
// Maria

<strong>Limpar a pilha</strong>
pilha.clear();
System.out.println(pilha.isEmpty()); // true
</code>
      </pre>
    </div>

    <div class="block" data-tags="java.time">
      <div class="title">ArrayDeque</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Alta performance de Inser√ß√µes e remo√ß√µes nas extremidades
- Mais r√°pido que Stack e LinkedList
- Pode ser usado como fila e pilha

<strong>Desvantagens</strong>
- N√£o permite elementos nulos
- N√£o √© thread-safe
- N√£o tem acesso aleat√≥rio por √≠ndice

Deque<String> deque = new ArrayDeque<>();

<strong>Adicionando elementos</strong>
deque.add("Ana");
deque.add("Carlos");
deque.add("Jo√£o");

<strong>Inserir no in√≠cio da deque</strong>
deque.addFirst("Maria");

<strong>Inserir no final da deque</strong>
deque.addLast("Jo√£o");

<strong>Remover elementos</strong>
System.out.println(deque.removeFirst()); // Maria
System.out.println(deque.removeLast());  // Jo√£o

<strong>Acessando elementos</strong>
System.out.println(deque.getFirst()); // Ana
System.out.println(deque.getLast());  // Jo√£o

<strong>Verificando se a deque cont√©m um elemento</strong>
System.out.println(deque.contains("Carlos")); // true
System.out.println(deque.contains("Ana"));    // true

<strong>Remover um elemento espec√≠fico</strong>
deque.remove("Carlos");

<strong>Verificando o tamanho da deque</strong>
System.out.println(deque.size()); // 2

<strong>Iterando sobre os elementos</strong>
for (String nome : deque) {
    System.out.println(nome);
}
// Sa√≠da:
// Ana
// Jo√£o

<strong>Verificando se a deque est√° vazia</strong>
System.out.println(deque.isEmpty()); // false

<strong>Limpar a deque</strong>
deque.clear();
System.out.println(deque.isEmpty()); // true

<strong>Outros m√©todos</strong>

// Acessar o primeiro e √∫ltimo elementos sem remov√™-los
System.out.println(deque.peekFirst()); // Retorna o primeiro elemento, ou null
System.out.println(deque.peekLast());  // Retorna o √∫ltimo elemento, ou null

// Remover e retornar o primeiro ou √∫ltimo elemento
System.out.println(deque.pollFirst()); // Retorna e remove o primeiro elemento
System.out.println(deque.pollLast());  // Retorna e remove o √∫ltimo elemento

// Converter a deque para um array
Object[] array = deque.toArray();
String[] stringArray = deque.toArray(new String[0]);

</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.util">
      <div class="title">Queue com LinkedList</div>
      <pre>
<code>

<strong>Vantagens</strong>
- Permite elementos nulos
- Boa performance para inser√ß√µes e remo√ß√µes nas extremidades
- Ordem de inser√ß√£o preservada

<strong>Desvantagens</strong>  
- Mais lenta para acesso aleat√≥rio (get(index))
- n√£o √© segura para acesso concorrente

Queue<String> fila = new LinkedList<>();

<strong>Adicionando elementos na fila</strong>
fila.add("Ana");
fila.add("Carlos");
fila.offer("Beatriz"); // Alternativa ao add, retorna false se falhar

<strong>Removendo elementos da fila</strong>
System.out.println(fila.poll());  // Remove e retorna o primeiro (Ana)
System.out.println(fila.remove()); // Igual ao poll, mas lan√ßa exce√ß√£o se vazia

<strong>Visualizando o primeiro sem remover</strong>
System.out.println(fila.peek());   // Mostra "Carlos"
System.out.println(fila.element()); // Igual ao peek, mas lan√ßa exce√ß√£o se vazia

<strong>Verificando se a fila est√° vazia</strong>
System.out.println(fila.isEmpty()); // false

<strong>Tamanho da fila</strong>
System.out.println(fila.size()); // 2

<strong>Iterando sobre a fila</strong>
for (String pessoa : fila) {
    System.out.println(pessoa);
}

<strong>Limpando a fila</strong>
fila.clear();

<strong>Verificando se est√° vazia novamente</strong>
System.out.println(fila.isEmpty()); // true
</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.util">
      <div class="title">Queue com ArrayDeque</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Mais r√°pido que LinkedList e Stack para opera√ß√µes de inser√ß√£o e remo√ß√£o nas pontas
- Justamente por n√£o ser sincronizado, √© mais r√°pido em ambientes single-thread
- Funciona tanto como Queue (FIFO) quanto como Stack (LIFO)
- Melhor alternativa a Stack e LinkedList para filas

<strong>Desvantagens</strong>
- N√£o permite null
- N√£o √© thread-safe
- Embora transparente, redimensionar o buffer interno pode ter custo de performance.

Queue<String> fila = new ArrayDeque<>();

<strong>Adicionando elementos na fila</strong>
fila.add("Ana");
fila.offer("Carlos");
fila.offer("Joana");

<strong>Removendo elementos da fila</strong>
System.out.println(fila.poll());   // Remove "Ana"
System.out.println(fila.remove()); // Remove "Carlos"

<strong>Visualizando o primeiro sem remover</strong>
System.out.println(fila.peek());    // "Joana"
System.out.println(fila.element()); // Tamb√©m "Joana"

<strong>Verificar se a fila est√° vazia</strong>
System.out.println(fila.isEmpty()); // false

<strong>Tamanho da fila</strong>
System.out.println(fila.size()); // 1

<strong>Iterando sobre a fila</strong>
for (String nome : fila) {
    System.out.println(nome);
}

<strong>Limpando a fila</strong>
fila.clear();

<strong>Verificando se est√° vazia novamente</strong>
System.out.println(fila.isEmpty()); // true
</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.util">
      <div class="title">PriorityQueue</div>
      <pre>
<code>

<strong>Vantagens</strong>
- Ordena√ß√£o autom√°tica por prioridade
- Permite elementos duplicados

<strong>Desvantagens</strong>  
- n√£o √© segura para uso por m√∫ltiplas threads simultaneamente
- Ordem de itera√ß√£o n√£o √© garantida
- N√£o permite null
- Remo√ß√£o de elementos arbitr√°rios √© lenta (remove(Object))

<strong>Criando uma fila de prioridade (ordem natural)</strong>
PriorityQueue<Integer> fila = new PriorityQueue<>();

fila.add(50);
fila.add(10);
fila.add(30);

<strong>Iterando (ordem n√£o garantida aqui)</strong>
for (int num : fila) {
    System.out.println(num);
}

<strong>Removendo em ordem de prioridade</strong>
System.out.println(fila.poll()); // 10
System.out.println(fila.poll()); // 30
System.out.println(fila.poll()); // 50

<strong>Verificando a cabe√ßa da fila</strong>
fila.offer(20);
System.out.println(fila.peek()); // 20

<strong>Fila com Comparator (ordem reversa)</strong>
PriorityQueue<String> nomes = new PriorityQueue<>(Collections.reverseOrder());

nomes.offer("Carlos");
nomes.offer("Ana");
nomes.offer("Bruno");

System.out.println(nomes.poll()); // "Carlos"
System.out.println(nomes.poll()); // "Bruno"
System.out.println(nomes.poll()); // "Ana"

<strong>Outros m√©todos √∫teis</strong>
System.out.println(nomes.isEmpty());
System.out.println(nomes.size());
nomes.clear();
</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.util.concurrent">
      <div class="title">ConcurrentLinkedQueue</div>
      <pre>
<code>
<strong>Vantagens</strong>
- √© thread-safe, o que significa que v√°rias threads podem acessar 
e modificar a fila ao mesmo tempo sem causar inconsist√™ncias. 
Isso √© garantido atrav√©s de t√©cnicas de sincroniza√ß√£o internas, 
como opera√ß√µes at√¥micas (sem necessidade de bloqueios expl√≠citos).

<strong>Desvantagens</strong>
- N√£o permite null
- Se voc√™ precisar de funcionalidades como espera ativa at√© que 
a fila tenha elementos dispon√≠veis ou at√© que haja espa√ßo para 
adicionar novos elementos (como em ArrayBlockingQueue), 
a ConcurrentLinkedQueue n√£o oferece esse tipo de opera√ß√£o

<strong>Criando a fila concorrente</strong>
ConcurrentLinkedQueue<String> fila = new ConcurrentLinkedQueue<>();

<strong>Adicionando elementos</strong>
fila.add("Tarefa1");
fila.offer("Tarefa2");

<strong>Removendo elementos</strong>
System.out.println(fila.poll()); // Tarefa1
System.out.println(fila.poll()); // Tarefa2

<strong>Visualizando o primeiro elemento (sem remover)</strong>
fila.offer("Tarefa3");
System.out.println(fila.peek()); // Tarefa3

<strong>Iterando sobre os elementos</strong>
fila.offer("Tarefa4");
fila.offer("Tarefa5");
for (String tarefa : fila) {
    System.out.println(tarefa);
}

<strong>Verificando se est√° vazia</strong>
System.out.println(fila.isEmpty());

<strong>Obtendo o tamanho atual</strong>
System.out.println(fila.size());

<strong>Remover elemento espec√≠fico (como uma lista)</strong>
fila.remove("Tarefa4");
</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.util">
      <div class="title">HashSet</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Desempenho r√°pido em opera√ß√µes b√°sicas (add, remove, contains)
- N√£o permite elementos duplicados
- Em compara√ß√£o com outras implementa√ß√µes de Set, como TreeSet, 
o HashSet costuma ser mais eficiente em termos de uso de mem√≥ria.

<strong>Desvantagens</strong>
- N√£o garante ordem de itera√ß√£o.
- Como o HashSet usa tabelas de dispers√£o (hash tables) para armazenar 
os elementos, ele pode consumir mais mem√≥ria do que outras implementa√ß√µes
de Set, como TreeSet, especialmente quando o n√∫mero de elementos 
for muito grande.
- N√£o √© thread-safe
- Para elementos personalizados (objetos de classes que voc√™ cria), 
o HashSet depende de uma implementa√ß√£o correta dos m√©todos hashCode() 
e equals() para garantir a unicidade dos elementos

<strong>Criando o HashSet</strong>
Set<String> frutas = new HashSet<>();

<strong>Adicionando elementos</strong>
frutas.add("Ma√ß√£");
frutas.add("Banana");
frutas.add("Laranja");
frutas.add("Ma√ß√£"); // Ignorado (duplicado)

<strong>Exibindo elementos</strong>
for (String fruta : frutas) {
    System.out.println(fruta);
}

<strong>Verificar se cont√©m um elemento</strong>
System.out.println(frutas.contains("Banana")); // true

<strong>Remover elemento</strong>
frutas.remove("Laranja");

<strong>Tamanho do conjunto</strong>
System.out.println(frutas.size());

<strong>Verificar se est√° vazio</strong>
System.out.println(frutas.isEmpty());

<strong>Limpar o conjunto</strong>
frutas.clear();
</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.util">
      <div class="title">LinkedHashSet</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Mant√©m a ordem em que os elementos foram adicionados.

<strong>Desvantagens</strong>  
- Um pouco mais lento que HashSet em termos de performance.

<strong>Criando o LinkedHashSet</strong>
Set<String> frutas = new LinkedHashSet<>();

<strong>Adicionando elementos</strong>
frutas.add("Ma√ß√£");
frutas.add("Banana");
frutas.add("Laranja");
frutas.add("Ma√ß√£"); // Ignorado (duplicado)

<strong>Exibindo elementos (ordem preservada)</strong>
for (String fruta : frutas) {
    System.out.println(fruta);
}
// Sa√≠da: Ma√ß√£, Banana, Laranja

<strong>Verificar se cont√©m um elemento</strong>
System.out.println(frutas.contains("Banana")); // true

<strong>Remover elemento</strong>
frutas.remove("Ma√ß√£");

<strong>Tamanho do conjunto</strong>
System.out.println(frutas.size());

<strong>Verificar se est√° vazio</strong>
System.out.println(frutas.isEmpty());

<strong>Limpar o conjunto</strong>
frutas.clear();
</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.util">
      <div class="title">TreeSet</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Ordena automaticamente
- Ideal para dados que precisam estar sempre em ordem

<strong>Desvantagens</strong>
- Mais lento que HashSet e LinkedHashSet
- N√£o permite null

<strong>Criando o TreeSet</strong>
Set<String> frutas = new TreeSet<>();

<strong>Adicionando elementos</strong>
frutas.add("Banana");
frutas.add("Ma√ß√£");
frutas.add("Laranja");
frutas.add("Banana"); // Ignorado (duplicado)

<strong>Exibindo elementos (ordem natural)</strong>
for (String fruta : frutas) {
    System.out.println(fruta);
}
// Sa√≠da ordenada: Banana, Laranja, Ma√ß√£

<strong>Verificar se cont√©m um elemento</strong>
System.out.println(frutas.contains("Ma√ß√£")); // true

<strong>Remover elemento</strong>
frutas.remove("Banana");

<strong>Tamanho do conjunto</strong>
System.out.println(frutas.size());

<strong>Verificar se est√° vazio</strong>
System.out.println(frutas.isEmpty());

<strong>Limpar o conjunto</strong>
frutas.clear();

<strong>Ordena√ß√£o personalizada (opcional)</strong>
TreeSet<String> frutasOrdenadas = new TreeSet<>(
    Comparator.reverseOrder()
);
frutasOrdenadas.addAll(List.of("Banana", "Ma√ß√£", "Laranja"));
System.out.println(frutasOrdenadas); // [Ma√ß√£, Laranja, Banana]
</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.util">
      <div class="title">EnumSet</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Leve e r√°pido
- Ideal para enums
- Ocupa pouca mem√≥ria

<strong>Desvantagens</strong>
- S√≥ funciona com enums
- Ordem segue a ordem de declara√ß√£o do enum
  
<strong>Declarando um enum</strong>
enum DiaSemana {
    SEGUNDA, TERCA, QUARTA, QUINTA, SEXTA, SABADO, DOMINGO
}

<strong>Criando um EnumSet com todos os dias</strong>
EnumSet<DiaSemana> todosDias = EnumSet.allOf(DiaSemana.class);

<strong>Criando um EnumSet com dias √∫teis</strong>
EnumSet<DiaSemana> diasUteis = EnumSet.range(DiaSemana.SEGUNDA, DiaSemana.SEXTA);

<strong>Criando um EnumSet espec√≠fico</strong>
EnumSet<DiaSemana> fimDeSemana = EnumSet.of(DiaSemana.SABADO, DiaSemana.DOMINGO);

<strong>Adicionando um elemento</strong>
diasUteis.add(DiaSemana.SABADO);

<strong>Removendo um elemento</strong>
diasUteis.remove(DiaSemana.QUARTA);

<strong>Verificando se cont√©m</strong>
System.out.println(diasUteis.contains(DiaSemana.SEGUNDA)); // true

<strong>Iterando</strong>
for (DiaSemana dia : fimDeSemana) {
    System.out.println(dia);
}

<strong>Limpando</strong>
fimDeSemana.clear();
</code>
      </pre>
    </div>
    
    
    <div class="block" data-tags="java.util">
      <div class="title">HashMap</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Muito r√°pido para busca, inser√ß√£o e remo√ß√£o
- Ideal quando a ordem n√£o importa

<strong>Desvantagens</strong>
- Ordem imprevis√≠vel
- N√£o √© thread-safe

<strong>Criando um HashMap</strong>
HashMap&lt;String, Integer&gt; idades = new HashMap<>();

<strong>Adicionando elementos</strong>
idades.put("Ana", 25);
idades.put("Carlos", 30);
idades.put("Bruna", 28);

<strong>Acessando valor pela chave</strong>
System.out.println(idades.get("Ana")); // 25

<strong>Verificando se a chave existe</strong>
System.out.println(idades.containsKey("Carlos")); // true

<strong>Verificando se o valor existe</strong>
System.out.println(idades.containsValue(28)); // true

<strong>Removendo um elemento</strong>
idades.remove("Carlos");

<strong>Iterando com for-each</strong>
for (Map.Entry&lt;String, Integer&gt; entrada : idades.entrySet()) {
    System.out.println(entrada.getKey() + " -> " + entrada.getValue());
}

<strong>Iterando apenas pelas chaves</strong>
for (String nome : idades.keySet()) {
    System.out.println(nome);
}

<strong>Iterando apenas pelos valores</strong>
for (Integer idade : idades.values()) {
    System.out.println(idade);
}

<strong>Tamanho do mapa</strong>
System.out.println(idades.size());

<strong>Substituindo o valor de uma chave existente</strong>
idades.put("Ana", 26);

<strong>Limpar tudo</strong>
idades.clear();

<strong>Verificar se est√° vazio</strong>
System.out.println(idades.isEmpty()); // true
</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.util">
      <div class="title">LinkedHashMap</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Mant√©m a ordem de inser√ß√£o
- Boa previsibilidade para itera√ß√£o

<strong>Desvantagens</strong>
- Ligeiramente mais lento que HashMap

<strong>Criando um LinkedHashMap</strong>
LinkedHashMap&lt;String, Integer&gt; notas = new LinkedHashMap<>();

<strong>Adicionando elementos</strong>
notas.put("Maria", 9);
notas.put("Jo√£o", 7);
notas.put("Pedro", 8);

<strong>Preserva ordem de inser√ß√£o:</strong>
for (Map.Entry&lt;String, Integer&gt; entry : notas.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}

<strong>Acessando valor pela chave</strong>
System.out.println(notas.get("Maria")); // 9

<strong>Substituindo valor</strong>
notas.put("Maria", 10); // atualiza a nota

<strong>Verificando exist√™ncia</strong>
notas.containsKey("Jo√£o"); // true
notas.containsValue(8);    // true

<strong>Removendo um item</strong>
notas.remove("Jo√£o");

<strong>Iterando somente as chaves</strong>
for (String nome : notas.keySet()) {
    System.out.println(nome);
}

<strong>Iterando somente os valores</strong>
for (Integer nota : notas.values()) {
    System.out.println(nota);
}

<strong>Tamanho e limpeza</strong>
System.out.println(notas.size());
notas.clear();
System.out.println(notas.isEmpty());
</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.util">
      <div class="title">TreeMap</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Mant√©m as chaves ordenadas naturalmente (ou por um Comparator)
- √ötil para intervalos, buscas de menor/maior, etc.

<strong>Desvantagens</strong>
- Mais lento que HashMap e LinkedHashMap
- Custo de ordena√ß√£o (baseado em √°rvore vermelha-preta)

<strong>Criando um TreeMap</strong>
TreeMap&lt;String, Integer&gt; estoque = new TreeMap<>();

<strong>Adicionando elementos</strong>
estoque.put("Ma√ß√£", 30);
estoque.put("Banana", 20);
estoque.put("Laranja", 25);

<strong>Ordem natural (ordenado pela chave):</strong>
for (Map.Entry&lt;String, Integer&gt; entry : estoque.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}

<strong>Acessando um valor</strong>
System.out.println(estoque.get("Banana")); // 20

<strong>Substituindo valor</strong>
estoque.put("Banana", 22); // atualiza

<strong>Verificando exist√™ncia</strong>
estoque.containsKey("Ma√ß√£");    // true
estoque.containsValue(25);      // true

<strong>Removendo item</strong>
estoque.remove("Laranja");

<strong>Iterando pelas chaves</strong>
for (String fruta : estoque.keySet()) {
    System.out.println(fruta);
}

<strong>Iterando pelos valores</strong>
for (Integer quantidade : estoque.values()) {
    System.out.println(quantidade);
}

<strong>Primeiro e √∫ltimo elementos</strong>
System.out.println(estoque.firstKey()); // Banana
System.out.println(estoque.lastKey());  // Ma√ß√£

<strong>Tamanho e limpeza</strong>
System.out.println(estoque.size());
estoque.clear();
System.out.println(estoque.isEmpty());
</code>
      </pre>
    </div>

    <div class="block" data-tags="java.util">
      <div class="title">EnumMap</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Extremamente eficiente para chaves do tipo Enum, 
utilizando um array interno para armazenamento.
- Mais r√°pido e eficiente em termos de mem√≥ria quando 
comparado a outras implementa√ß√µes de Map.

<strong>Desvantagens</strong>
Somente pode ser usado com Enum como chave.
N√£o funciona bem quando as chaves n√£o s√£o enumeradas.

<strong>Criando um EnumMap</strong>
enum Fruta { MA√áA, BANANA, LARANJA }
EnumMap&lt;Fruta, Integer&gt; estoque = new EnumMap&lt;&gt;(Fruta.class);

<strong>Adicionando elementos</strong>
estoque.put(Fruta.MA√áA, 30);
estoque.put(Fruta.BANANA, 20);
estoque.put(Fruta.LARANJA, 25);

<strong>Iterando atrav√©s do EnumMap</strong>
for (Map.Entry&lt;Fruta, Integer&gt; entry : estoque.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}

<strong>Acessando um valor</strong>
System.out.println(estoque.get(Fruta.BANANA)); // 20

<strong>Verificando exist√™ncia</strong>
System.out.println(estoque.containsKey(Fruta.MA√áA));    // true
System.out.println(estoque.containsValue(25));          // true

<strong>Removendo item</strong>
estoque.remove(Fruta.LARANJA);

<strong>Tamanho e limpeza</strong>
System.out.println(estoque.size()); // 2
estoque.clear();
System.out.println(estoque.isEmpty()); // true
</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.util">
      <div class="title">ConcurrentHashMap</div>
      <pre>
<code>
<strong>Vantagens</strong>
- ConcurrentHashMap √© thread-safe sem a necessidade 
de bloquear toda a estrutura.
- Excelente para ambientes concorrentes onde 
m√∫ltiplos threads acessam o mapa simultaneamente.
- Opera√ß√µes de leitura s√£o altamente eficientes.

<strong>Desvantagens</strong>
- Mais lento que outras implementa√ß√µes de Map 
em ambientes de √∫nico thread, devido ao 
gerenciamento de concorr√™ncia.
A API oferece algumas complexidades adicionais 
(exemplo: opera√ß√£o computeIfAbsent).

<strong>Criando um ConcurrentHashMap</strong>
ConcurrentHashMap&lt;String, Integer&gt; mapaConcorrente = new ConcurrentHashMap&lt;&gt;();

<strong>Adicionando elementos</strong>
mapaConcorrente.put("Ma√ß√£", 10);
mapaConcorrente.put("Banana", 15);
mapaConcorrente.put("Laranja", 20);

<strong>Iterando atrav√©s do ConcurrentHashMap</strong>
for (Map.Entry&lt;String, Integer&gt; entry : mapaConcorrente.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}

<strong>Acessando um valor</strong>
System.out.println(mapaConcorrente.get("Banana")); // 15

<strong>Verificando exist√™ncia</strong>
System.out.println(mapaConcorrente.containsKey("Ma√ß√£"));  // true
System.out.println(mapaConcorrente.containsValue(25));    // false

<strong>Removendo item</strong>
mapaConcorrente.remove("Laranja");

<strong>Usando putIfAbsent</strong>
mapaConcorrente.putIfAbsent("Ma√ß√£", 25);  // N√£o altera, pois "Ma√ß√£" j√° existe

<strong>Tamanho e limpeza</strong>
System.out.println(mapaConcorrente.size());  // 2
mapaConcorrente.clear();
System.out.println(mapaConcorrente.isEmpty()); // true
</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.util">
      <div class="title">Collections.synchronizedList</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Garante que a lista seja thread-safe, 
ou seja, segura para acesso em m√∫ltiplas threads simult√¢neas, 
com a sincroniza√ß√£o embutida.
- √ötil quando se trabalha em ambientes concorrentes, onde v√°rias 
threads podem acessar ou modificar a lista.

<strong>Desvantagens</strong>  
- A sincroniza√ß√£o pode resultar em algum overhead de performance, 
especialmente em opera√ß√µes de leitura, dependendo do n√∫mero de 
threads simult√¢neas acessando a lista.

- Requer que todas as opera√ß√µes de leitura e itera√ß√£o sejam feitas 
dentro de um bloco synchronized, o que pode ser um pouco mais 
complexo de gerenciar.

<strong>Criando uma lista sincronizada</strong>
List&lt;String&gt; lista = new ArrayList&lt;&gt;();
List&lt;String&gt; listaSincronizada = Collections.synchronizedList(lista);

<strong>Adicionando elementos</strong>
listaSincronizada.add("Ma√ß√£");
listaSincronizada.add("Banana");
listaSincronizada.add("Laranja");

<strong>Iterando atrav√©s da lista sincronizada</strong>
// Para itera√ß√£o, √© necess√°rio sincronizar explicitamente o bloco de c√≥digo
synchronized (listaSincronizada) {
    for (String item : listaSincronizada) {
        System.out.println(item);
    }
}

<strong>Verificando se cont√©m um elemento</strong>
System.out.println(listaSincronizada.contains("Banana"));  // true

<strong>Removendo um item</strong>
listaSincronizada.remove("Laranja");

<strong>Verificando o tamanho</strong>
System.out.println(listaSincronizada.size());  // 2

<strong>Limpar a lista</strong>
listaSincronizada.clear();
System.out.println(listaSincronizada.isEmpty());  // true
</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.util">
      <div class="title">Collections.unmodifiableList</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Garante que a lista n√£o seja modificada ap√≥s ser criada, 
o que √© ideal para situa√ß√µes em que voc√™ deseja garantir 
que os dados n√£o sejam alterados acidentalmente ou 
durante o uso em APIs p√∫blicas.
- Aumenta a seguran√ßa e integridade dos dados.

<strong>Desvantagens</strong>
- N√£o permite modifica√ß√µes, o que pode ser uma limita√ß√£o 
quando for necess√°rio realizar altera√ß√µes na lista depois
de sua cria√ß√£o.
- Qualquer tentativa de modifica√ß√£o resultar√° em 
uma UnsupportedOperationException
  
<strong>Criando uma lista imut√°vel</strong>
List&lt;String&gt; lista = new ArrayList&lt;&gt;();
lista.add("Ma√ß√£");
lista.add("Banana");
lista.add("Laranja");

// Tornando a lista imut√°vel
List&lt;String&gt; listaImutavel = Collections.unmodifiableList(lista);

<strong>Tentando modificar a lista imut√°vel</strong>
try {
    listaImutavel.add("Uva");  // Lan√ßar√° uma exce√ß√£o UnsupportedOperationException
} catch (UnsupportedOperationException e) {
    System.out.println("N√£o √© poss√≠vel modificar uma lista imut√°vel.");
}

<strong>Acessando um item da lista imut√°vel</strong>
System.out.println(listaImutavel.get(0));  // Ma√ß√£

<strong>Verificando o tamanho da lista</strong>
System.out.println(listaImutavel.size());  // 3

<strong>Verificando se cont√©m um item</strong>
System.out.println(listaImutavel.contains("Banana"));  // true
</code>
      </pre>
    </div>

    <h2 class="section-title">üìò Thread</h2>

    <div class="block" data-tags="java.lang">
      <div class="title">Thread (java.lang.Thread)</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Permite que seu programa execute tarefas simultaneamente.
- Pode melhorar o desempenho em sistemas com m√∫ltiplos n√∫cleos.
- Ideal para opera√ß√µes demoradas, como chamadas de rede ou leitura de arquivos, sem bloquear a interface principal.

<strong>Desvantagens</strong>
- Introduz complexidade no c√≥digo.
- Pode causar erros dif√≠ceis de detectar como race conditions, deadlocks e concorr√™ncia incorreta.
- Requer cuidado com o uso de recursos compartilhados.

<strong>Criando uma Thread estendendo a classe Thread</strong>
class MinhaThread extends Thread {
    public void run() {
        System.out.println("Executando na thread: " + Thread.currentThread().getName());
    }
}

MinhaThread t1 = new MinhaThread();
t1.start();  // Inicia a thread

<strong>Criando uma Thread implementando Runnable</strong>
class MinhaTarefa implements Runnable {
    public void run() {
        System.out.println("Executando tarefa em: " + Thread.currentThread().getName());
    }
}

Thread t2 = new Thread(new MinhaTarefa());
t2.start();  // Inicia a thread

<strong>Usando express√£o lambda com Runnable (Java 8+)</strong>
Thread t3 = new Thread(() -> {
    System.out.println("Executando com lambda em: " + Thread.currentThread().getName());
});
t3.start();

<strong>Esperando uma Thread terminar (join)</strong>
try {
    t1.join();  // Espera a thread t1 terminar
    t2.join();
    t3.join();
} catch (InterruptedException e) {
    e.printStackTrace();
}

<strong>Verificando se uma Thread est√° viva</strong>
System.out.println(t1.isAlive());  // true ou false
</code>
        </pre>
      </div>
      
      <div class="block" data-tags="java.util.concurrent">
        <div class="title">ExecutorService</div>
        <pre>
<code>
<strong>Vantagens</strong>
- Gerencia um pool de threads, evitando a cria√ß√£o e destrui√ß√£o frequente de threads.
- Ideal para aplica√ß√µes que precisam executar m√∫ltiplas tarefas de forma eficiente.
- Fornece m√©todos para controle mais refinado da execu√ß√£o de tarefas.

<strong>Desvantagens</strong>
- Precisa ser finalizado corretamente com shutdown().
- Pode ser complexo para tarefas que dependem entre si.

<strong>Criando um ExecutorService com um pool fixo</strong>
ExecutorService executor = Executors.newFixedThreadPool(3);

<strong>Executando uma tarefa</strong>
executor.execute(() -> {
    System.out.println("Executando em thread do pool: " + Thread.currentThread().getName());
});

<strong>Executando tarefa com retorno (Callable)</strong>
Callable&lt;String&gt; tarefa = () -> {
    return "Resultado da tarefa";
};

Future&lt;String&gt; futuro = executor.submit(tarefa);
try {
    System.out.println(futuro.get());  // Espera e obt√©m o resultado
} catch (Exception e) {
    e.printStackTrace();
}

<strong>Encerrando o ExecutorService</strong>
executor.shutdown();
</code>
        </pre>
      </div>
      
      <div class="block" data-tags="java.lang">
        <div class="title">synchronized</div>
        <pre>
<code>
<strong>Vantagens</strong>
- Garante que apenas uma thread execute um bloco de c√≥digo por vez.
- Evita problemas como race conditions ao acessar recursos compartilhados.

<strong>Desvantagens</strong>
- Pode causar gargalos se mal utilizado.
- Pode levar a deadlocks se houver m√° coordena√ß√£o entre os recursos.

<strong>M√©todo sincronizado</strong>
public synchronized void incrementar() {
    contador++;
}

<strong>Bloco sincronizado</strong>
public void incrementar() {
    synchronized(this) {
        contador++;
    }
}

<strong>Sincronizando em um objeto espec√≠fico</strong>
Object lock = new Object();

public void tarefa() {
    synchronized(lock) {
        // Somente uma thread pode acessar aqui por vez
        System.out.println("Acessando recurso com lock");
    }
}

<strong>Evite isso!</strong>
// Sincronizar em objetos mut√°veis, como Strings ou listas, pode ser perigoso
</code>
        </pre>
      </div>
      
      <div class="block" data-tags="java-concorrencia">
        <div class="title">wait(), notify(), notifyAll()</div>
        <pre>
<code>
<strong>O que s√£o?</strong>
- S√£o m√©todos da classe Object usados para comunica√ß√£o entre threads.
- Devem ser usados dentro de blocos sincronizados (com synchronized).

<strong>wait()</strong>
- Faz a thread atual "esperar" at√© que outra thread chame notify() ou notifyAll().
- Libera o monitor do objeto (o lock), permitindo que outras threads entrem no bloco synchronized.

<strong>notify()</strong>
- Acorda uma thread que est√° esperando (`wait()`) no mesmo objeto monitor.

<strong>notifyAll()</strong>
- Acorda todas as threads que est√£o esperando (`wait()`) no objeto monitor.

<strong>Regras importantes</strong>
- S√≥ funcionam dentro de blocos sincronizados (sen√£o lan√ßam IllegalMonitorStateException).
- Sempre use um objeto comum para `wait()` e `notify()` (ex: `synchronized (this)`).

<strong>Exemplo: Produtor e Consumidor</strong>
class Buffer {
    private int valor;
    private boolean disponivel = false;

    public synchronized void produzir(int novoValor) {
        while (disponivel) {
            try {
                wait();  // Espera at√© que o valor seja consumido
            } catch (InterruptedException e) {}
        }
        valor = novoValor;
        disponivel = true;
        System.out.println("Produzido: " + valor);
        notify();  // Avisa que h√° um novo valor dispon√≠vel
    }

    public synchronized int consumir() {
        while (!disponivel) {
            try {
                wait();  // Espera at√© que um valor seja produzido
            } catch (InterruptedException e) {}
        }
        disponivel = false;
        System.out.println("Consumido: " + valor);
        notify();  // Avisa que o buffer est√° livre para produ√ß√£o
        return valor;
    }
}

<strong>Uso das threads</strong>
Buffer buffer = new Buffer();

Thread produtor = new Thread(() -> {
    for (int i = 0; i < 5; i++) {
        buffer.produzir(i);
    }
});

Thread consumidor = new Thread(() -> {
    for (int i = 0; i < 5; i++) {
        buffer.consumir();
    }
});

produtor.start();
consumidor.start();
</code>
        </pre>
      </div>
      
      <div class="block" data-tags="java-concorrencia">
        <div class="title">wait()/notify() vs BlockingQueue</div>
        <pre>
<code>
<strong>wait()/notify()</strong>
‚úÖ Mais controle e flexibilidade.
‚ö†Ô∏è Mais c√≥digo, f√°cil de errar (risco de deadlock e race conditions).
üîß Ideal quando voc√™ precisa de uma l√≥gica de sincroniza√ß√£o customizada.

<strong>BlockingQueue (java.util.concurrent)</strong>
‚úÖ Simples de usar e segura para m√∫ltiplas threads.
‚úÖ J√° trata sincroniza√ß√£o internamente.
‚úÖ Evita uso manual de synchronized, wait() e notify().
üîß Ideal para cen√°rios Produtor-Consumidor.

<strong>Exemplo com BlockingQueue</strong>
import java.util.concurrent.*;

BlockingQueue&lt;Integer&gt; fila = new ArrayBlockingQueue&lt;&gt;(10);

Thread produtor = new Thread(() -> {
    try {
        for (int i = 0; i < 5; i++) {
            fila.put(i);  // Espera se a fila estiver cheia
            System.out.println("Produzido: " + i);
        }
    } catch (InterruptedException e) {}
});

Thread consumidor = new Thread(() -> {
    try {
        for (int i = 0; i < 5; i++) {
            int valor = fila.take();  // Espera se a fila estiver vazia
            System.out.println("Consumido: " + valor);
        }
    } catch (InterruptedException e) {}
});

produtor.start();
consumidor.start();

<strong>Quando usar cada um?</strong>
üß† Use wait()/notify() quando:
- Precisa de l√≥gica mais complexa ou sincroniza√ß√£o em diferentes objetos.
- Est√° aprendendo o funcionamento de baixo n√≠vel de threads.

üöÄ Use BlockingQueue quando:
- Quer simplicidade, seguran√ßa e performance.
- Est√° implementando produtores/consumidores com foco em robustez.
</code>
        </pre>
      </div>
      
      <div class="block" data-tags="java-concorrencia">
        <div class="title">Semaphore</div>
        <pre>
<code>
<strong>O que √©?</strong>
- Controla o n√∫mero de threads que podem acessar um recurso ao mesmo tempo.
- √ötil para limitar o acesso a uma quantidade finita de recursos (como conex√µes de banco, impressoras, etc).

<strong>Exemplo</strong>
import java.util.concurrent.Semaphore;

Semaphore semaforo = new Semaphore(2);  // Limite de 2 threads simult√¢neas

Runnable tarefa = () -> {
    try {
        semaforo.acquire();  // Pede permiss√£o
        System.out.println(Thread.currentThread().getName() + " entrou");
        Thread.sleep(1000);
        System.out.println(Thread.currentThread().getName() + " saiu");
    } catch (InterruptedException e) {
    } finally {
        semaforo.release();  // Libera permiss√£o
    }
};

for (int i = 0; i < 5; i++) {
    new Thread(tarefa).start();
}

<strong>Resultado:</strong>
No m√°ximo 2 threads executam o bloco "cr√≠tico" ao mesmo tempo.
</code>
        </pre>
      </div>
      
      <div class="block" data-tags="java-concorrencia">
        <div class="title">CountDownLatch</div>
        <pre>
<code>
<strong>O que √©?</strong>
- Permite que uma ou mais threads esperem at√© que outras completem alguma opera√ß√£o.

<strong>Exemplo: Esperar 3 tarefas finalizarem</strong>
import java.util.concurrent.CountDownLatch;

CountDownLatch latch = new CountDownLatch(3);

Runnable tarefa = () -> {
    System.out.println(Thread.currentThread().getName() + " trabalhando...");
    try { Thread.sleep(1000); } catch (InterruptedException e) {}
    latch.countDown();  // Reduz o contador
};

new Thread(tarefa).start();
new Thread(tarefa).start();
new Thread(tarefa).start();

try {
    latch.await();  // Espera o contador chegar a 0
    System.out.println("Todas as tarefas conclu√≠das!");
} catch (InterruptedException e) {}

<strong>Ideal para</strong>
- Esperar m√∫ltiplas tarefas antes de seguir.
</code>
        </pre>
      </div>

      <div class="block" data-tags="java-concorrencia">
        <div class="title">CyclicBarrier</div>
        <pre>
<code>
<strong>O que √©?</strong>
- Permite que um grupo de threads esperem umas pelas outras at√© atingirem um "ponto de barreira".
- Pode ser reutilizado (diferente do CountDownLatch).

<strong>Exemplo: 3 threads esperam juntas</strong>
import java.util.concurrent.CyclicBarrier;

CyclicBarrier barreira = new CyclicBarrier(3, () -> {
    System.out.println("Todas chegaram √† barreira! Executando a√ß√£o final.");
});

Runnable tarefa = () -> {
    try {
        System.out.println(Thread.currentThread().getName() + " pronto");
        barreira.await();  // Espera as outras
        System.out.println(Thread.currentThread().getName() + " passou a barreira");
    } catch (Exception e) {}
};

for (int i = 0; i < 3; i++) {
    new Thread(tarefa).start();
}

<strong>Ideal para</strong>
- Sincronizar fases de execu√ß√£o entre threads.
</code>
        </pre>
      </div>
      
      <div class="block" data-tags="java-concorrencia">
        <div class="title">CompletableFuture</div>
        <pre>
<code>
<strong>O que √©?</strong>
- Representa uma computa√ß√£o ass√≠ncrona.
- Permite encadear tarefas de forma n√£o bloqueante.

<strong>Exemplo simples</strong>
import java.util.concurrent.*;

CompletableFuture&lt;String&gt; futuro = CompletableFuture.supplyAsync(() -> {
    return "Resultado";
});

futuro.thenAccept(resultado -> {
    System.out.println("Recebido: " + resultado);
});

<strong>Encadeando tarefas</strong>
CompletableFuture&lt;String&gt; encadeado = futuro
    .thenApply(resultado -> resultado + " modificado")
    .thenApply(String::toUpperCase);

System.out.println(encadeado.get());  // Resultado MODIFICADO

<strong>Ideal para</strong>
- Executar tarefas ass√≠ncronas de forma fluente e eficiente.
</code>
        </pre>
      </div>
      
      <div class="block" data-tags="java-concorrencia">
        <div class="title">ForkJoinPool</div>
        <pre>
<code>
<strong>O que √©?</strong>
- Um pool de threads especializado em dividir tarefas recursivas em subtarefas menores.
- Ideal para paralelizar tarefas intensivas (divide and conquer).

<strong>Exemplo b√°sico</strong>
import java.util.concurrent.*;

class SomaTask extends RecursiveTask&lt;Integer&gt; {
    int inicio, fim;

    SomaTask(int inicio, int fim) {
        this.inicio = inicio;
        this.fim = fim;
    }

    protected Integer compute() {
        if (fim - inicio &lt;= 10) {
            int soma = 0;
            for (int i = inicio; i &lt;= fim; i++) soma += i;
            return soma;
        } else {
            int meio = (inicio + fim) / 2;
            SomaTask t1 = new SomaTask(inicio, meio);
            SomaTask t2 = new SomaTask(meio + 1, fim);
            t1.fork();
            return t2.compute() + t1.join();
        }
    }
}

ForkJoinPool pool = new ForkJoinPool();
int resultado = pool.invoke(new SomaTask(1, 100));
System.out.println("Soma: " + resultado);

<strong>Ideal para</strong>
- Tarefas grandes que podem ser divididas em partes menores.
</code>
        </pre>
      </div>
      
      <div class="block" data-tags="java-concorrencia">
        <div class="title">ForkJoinPool</div>
        <pre>
<code>
<strong>Paralelismo vs Concorr√™ncia</strong>

<strong>Paralelismo:</strong> Refere-se √† execu√ß√£o de m√∫ltiplas tarefas 
simultaneamente em diferentes n√∫cleos do processador.

<strong>Concorr√™ncia:</strong> Refere-se √† execu√ß√£o de m√∫ltiplas tarefas 
de forma alternada (intercalada), em um √∫nico n√∫cleo ou 
m√∫ltiplos n√∫cleos, com a ideia de que o processador 
troca rapidamente entre elas.

<strong>Exemplo de paralelismo:</strong>

Usando ForkJoinPool para dividir um problema em subtarefas 
e execut√°-las simultaneamente.

<strong>Exemplo de concorr√™ncia:</strong>

Usando ExecutorService para gerenciar tarefas que n√£o precisam 
ser executadas simultaneamente, mas podem ser divididas para 
otimizar o tempo total de execu√ß√£o.
</code>
        </pre>
      </div>

      <h2 class="section-title">üìò Strams</h2>
      
      <div class="block" data-tags="java-concorrencia">
        <div class="title">Streams</div>
        <pre>
<code>
<strong>Cria√ß√£o de Streams</strong>

List<String> lista = Arrays.asList(
  "ma√ß√£", "banana", "laranja");
Stream<String> stream = lista.stream();
    
int[] numeros = {1, 2, 3, 4, 5};
IntStream streamNumeros = Arrays
  .stream(numeros);

Stream<String> stream = Stream.of("a", "b", "c");

<strong>Streams - filter</strong>

List<String> lista = Arrays.asList(
  "ma√ß√£", "banana", "laranja");
List<String> listaFiltrada = lista.stream()
              .filter(s -> s.startsWith("b"))
              .collect(Collectors
              .toList());

System.out.println(listaFiltrada); // [banana]

<strong>Streams - map</strong>

List<String> lista = Arrays.asList(
  "ma√ß√£", "banana", "laranja");
List<String> listaMaiuscula = lista.stream()
                    .map(String::toUpperCase)
                    .collect(Collectors
                    .toList());
System.out.println(listaMaiuscula); 
// [MA√á√É, BANANA, LARANJA]
</code> 
        </pre>
      </div>

      <div class="block" data-tags="java-streams">
        <div class="title">Streams</div>
        <pre>
<code>
<strong>Streams - distinct</strong>

List<String> lista = Arrays.asList(
  "ma√ß√£", "banana", "laranja", "banana");
List<String> listaDistinta = lista.stream()
                      .distinct()
                      .collect(Collectors
                      .toList());
System.out.println(listaDistinta); 
// [ma√ß√£, banana, laranja]

<strong>Streams - sorted</strong>

List<String> lista = Arrays.asList(
  "ma√ß√£", "banana", "laranja");
List<String> listaOrdenada = lista.stream()
                      .sorted()
                      .collect(Collectors
                      .toList());
System.out.println(listaOrdenada); 
// [banana, laranja, ma√ß√£]

<strong>Streams - forEach</strong>

List<String> lista = Arrays.asList(
  "ma√ß√£", "banana", "laranja");
lista.stream()
  .forEach(System.out::println); 
  // Imprime cada item da lista
</code>
              </pre>      
            </div>

      <div class="block" data-tags="java-streams">
        <div class="title">Streams</div>
        <pre>
<code>
<strong>Streams - reduce</strong>  

//Realiza uma redu√ß√£o em um stream 
de elementos, combinando-os de 
acordo com um acumulador.

List<Integer> lista = Arrays
  .asList(1, 2, 3, 4);
int soma = lista.stream()
                .reduce(0, Integer::sum);
System.out.println(soma); // 10
  
<strong>Streams - count</strong>

List<String> lista = Arrays
  .asList("ma√ß√£", "banana", "laranja");
long count = lista.stream().count();
System.out.println(count); // 3

<strong>Streams - paralelo</strong>

List<Integer> lista = Arrays
  .asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
int somaParalela = lista
  .parallelStream()
  .reduce(0, Integer::sum);
System.out.println(somaParalela); // 55
</code>
          </pre>
        </div>

      <div class="block" data-tags="java-streams">
        <div class="title">Streams</div>
        <pre>
<code>
<strong>Streams - Map</strong>

List<String> nomes = Arrays
  .asList("ana", "jo√£o", "maria");

List<String> nomesMaiusculos = nomes.stream()
  // Transforma cada nome em MAI√öSCULO
  .map(String::toUpperCase)
  .collect(Collectors.toList());
  
System.out.println(nomesMaiusculos); 
// [ANA, JO√ÉO, MARIA]
  
<strong>Streams - FlatMap</strong>

List<List<String>> nomesAninhados = Arrays.asList(
  Arrays.asList("ana", "jo√£o"),
  Arrays.asList("maria", "pedro")
);

List<String> nomes = nomesAninhados.stream()
  // "Achata" os sub-streams em um s√≥
  .flatMap(List::stream) 
  .collect(Collectors.toList());

System.out.println(nomes); 
// [ana, jo√£o, maria, pedro]
</code>
        </pre>
      </div>
      
      <div class="block" data-tags="java-streams">
        <div class="title">Streams</div>
        <pre>
<code>
<strong>Streams - Limit</strong>

List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5, 6);

List<Integer> primeirosTres = numeros.stream()
    .limit(3) // Pega s√≥ os 3 primeiros
    .collect(Collectors.toList());

System.out.println(primeirosTres); // [1, 2, 3]
  
<strong>Streams - Skip</strong>

List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5, 6);

List<Integer> depoisDosDoisPrimeiros = numeros.stream()
    .skip(2) // Pula os dois primeiros
    .collect(Collectors.toList());

System.out.println(depoisDosDoisPrimeiros); 
// [3, 4, 5, 6]
</code>
        </pre>
      </div>

      <div class="block" data-tags="java-streams">
        <div class="title">Streams</div>
        <pre>
<code>
<strong>Streams - peek</strong>

List<String> nomes = Arrays
  .asList("ana", "jo√£o", "maria");

List<String> resultado = nomes.stream()
.peek(
  nome -> System.out.println(
    "Original: " + nome))
.map(String::toUpperCase)
.peek(nome -> System.out.println(
  "Mai√∫sculo: " + nome))
.collect(Collectors.toList());

System.out.println(resultado); 
// [ANA, JO√ÉO, MARIA]      
</code>
        </pre>
      </div>

      <h2 class="section-title">üìò Tipos de Classe</h2>

      <div class="block" data-tags="java-streams">
        <div class="title">Classes</div>
        <pre>
<code>
A forma geral da declara√ß√£o de uma classe 
√© a seguinte

[modificadores] class [nome classe] extends 
[nome super] implements [nome interface]

<strong>Modificadores</strong>

<strong>public: </strong>permite definir classes p√∫blicas. 
Estas classes s√£o acess√≠veis a partir de 
qualquer objeto, independentemente do package. 
Uma classe p√∫blica deve ser a √∫nica classe 
desse tipo no arquivo em que est√° declarada e 
o nome do arquivo deve ser igual ao da classe.

<strong>friendly:</strong> se nenhum modificador de classe for
especificado, ent√£o a classe ser√° considerada 
friendly. Apenas os objetos integrantes do 
mesmo package podem utilizar uma 
classe friendly.

<strong>final:</strong> Uma classe final pode ser instanciada, 
mas n√£o pode ser derivada, isto √©, n√£o pode 
ser superclasse de nenhuma subclasse. Algumas 
classes predefinidas no ambiente Java t√™m esta 
propriedade. Outras n√£o, como as classes no 
java.awt, por exemplo.

<strong>abstract:</strong> Classes abstratas s√£o aquelas que 
cont√©m ao menos um m√©todo incompleto. 
Desse modo uma classe abstrata n√£o pode 
ser instanciada, mas pode ser derivada. 
Neste caso, a subclasse deve prover o corpo 
do m√©todo para que possa ser instanciada. 
Isto √© muito √∫til quando desejamos 
definir em uma classe regras gerais para o 
comportamento de uma parte do programa, 
para que, mais tarde, as regras mais 
espec√≠ficas sejam introduzidas por subclasses.

<strong>sealed: </strong> Quando uma classe √© marcada como 
<code>sealed</code>, ela deve especificar quais subclasses 
podem herd√°-la usando a cl√°usula <code>permits</code>.
</code>
        </pre>
      </div>

      <div class="block" data-tags="java-classes">
        <div class="title">Classe p√∫blica</div>
        <pre>
<code>
<strong>public:</strong> O modificador <code>public</code> define 
uma classe que pode ser acessada a partir 
de qualquer outro pacote no projeto.

<strong>Regras importantes:</strong>
- Apenas uma classe <code>public</code> pode existir por 
arquivo .java.
- O nome do arquivo deve ser o mesmo da classe 
p√∫blica.
- A classe pode ser acessada diretamente por 
outras classes.

<strong>Exemplo:</strong>

// Arquivo: MinhaClasse.java
public class MinhaClasse {
    public void saudacao() {
        System.out.println("Ol√°! Eu sou uma 
        classe p√∫blica.");
    }
}

// Em outro arquivo no mesmo ou outro pacote:
public class Teste {
    public static void main(String[] args) {
        MinhaClasse obj = new MinhaClasse();
        obj.saudacao();
    }
}

<strong>Uso comum:</strong> Classes p√∫blicas s√£o usadas para 
expor funcionalidades principais, como APIs, 
servi√ßos, controladores ou classes principais 
com <code>main()</code>.
</code>
        </pre>
      </div>

      <div class="block" data-tags="java-classes">
        <div class="title">Classe friendly (default)</div>
        <pre>
<code>
<strong>friendly (ou default):</strong> Quando uma classe n√£o 
possui nenhum modificador de acesso expl√≠cito 
como <code>public</code>, <code>protected</code> ou <code>private</code>, ela √© 
considerada uma classe <strong>friendly</strong> ou de acesso 
<strong>package-private</strong>.

<strong>Comportamento:</strong>
- S√≥ pode ser acessada por outras classes 
dentro do mesmo pacote.
- N√£o pode ser acessada por classes de 
pacotes diferentes.

<strong>Exemplo:</strong>

// Arquivo: MinhaClasseAmiga.java
class MinhaClasseAmiga {
    void saudacao() {
        System.out.println(
          "Ol√°! Eu sou uma classe friendly.");
    }
}

// Outra classe no mesmo pacote
public class Teste {
    public static void main(String[] args) {
        MinhaClasseAmiga obj = new MinhaClasseAmiga();
        obj.saudacao();  // Funciona normalmente
    }
}

<strong>Exemplo em outro pacote:</strong>
// Isso causar√° erro de compila√ß√£o
import outro.pacote.MinhaClasseAmiga;

public class OutroTeste {
    public static void main(String[] args) {
        MinhaClasseAmiga obj = new MinhaClasseAmiga(); // Erro
    }
}

<strong>Uso comum:</strong> Classes friendly s√£o √∫teis para 
encapsular funcionalidades internas que 
n√£o devem ser expostas para outros pacotes.
</code>
        </pre>
      </div>
      
      <div class="block" data-tags="java-classes">
        <div class="title">Classe final</div>
        <pre>
<code>
<strong>final:</strong> Uma classe declarada com o modificador 
<code>final</code> n√£o pode ser estendida. Isso significa 
que nenhuma outra classe poder√° herdar dela.

<strong>Comportamento:</strong>
- Pode ser instanciada normalmente.
- N√£o pode servir de superclasse para outras 
classes.

<strong>Exemplo:</strong>

// Arquivo: Utilidade.java
public final class Utilidade {
    public static void imprimir(String texto) {
        System.out.println(texto);
    }
}

// Tentando estender a classe final (causar√° erro)
public class MinhaUtilidade extends Utilidade {  // ERRO!
    // N√£o √© poss√≠vel herdar de uma classe final
}

<strong>Uso comum:</strong>
- Quando se quer garantir que a implementa√ß√£o 
  da classe n√£o ser√° alterada por heran√ßa.
- Muito usado em classes utilit√°rias (como <code>java.lang.Math</code> ou <code>java.lang.String</code>).

<strong>Observa√ß√£o:</strong>
- Embora a classe n√£o possa ser estendida, 
  seus m√©todos ainda podem ser sobrecarregados 
  (overload) dentro da pr√≥pria classe, 
  se houver necessidade.
</code>
        </pre>
      </div>
     
      <div class="block" data-tags="java-classes">
        <div class="title">Classe abstract</div>
        <pre>
<code>
<strong>abstract:</strong> Uma classe abstrata serve como modelo 
para outras classes. Ela pode conter m√©todos 
com ou sem implementa√ß√£o.

<strong>Comportamento:</strong>
- N√£o pode ser instanciada diretamente.
- Pode conter m√©todos abstratos (sem corpo).
- Deve ser estendida por outra classe que 
  implemente os m√©todos abstratos.

<strong>Exemplo:</strong>

abstract class Animal {
    // M√©todo abstrato (sem corpo)
    abstract void emitirSom();

    // M√©todo com implementa√ß√£o
    void dormir() {
        System.out.println("Dormindo...");
    }
}

// Classe concreta que estende a abstrata
class Cachorro extends Animal {
    @Override
    void emitirSom() {
        System.out.println("Latindo...");
    }
}

public class Main {
    public static void main(String[] args) {
        // Animal a = new Animal(); // ERRO! Classe abstrata n√£o pode ser instanciada
        Cachorro c = new Cachorro();
        c.emitirSom();  // Latindo...
        c.dormir();     // Dormindo...
    }
}

<strong>Uso comum:</strong>
- Definir estruturas e comportamentos que devem 
  ser implementados pelas subclasses.
- Fornecer m√©todos utilit√°rios ou comuns com 
  implementa√ß√£o padr√£o.

<strong>Observa√ß√£o:</strong>
- Uma classe abstrata pode conter atributos,
  construtores e m√©todos concretos (com corpo).
- Pode ou n√£o ter m√©todos abstratos.
</code>
        </pre>
      </div>

      <div class="block" data-tags="java-classes">
        <div class="title">Classe sealed</div>
        <pre>
<code>
<strong>sealed:</strong> Uma classe sealed (selada) permite 
controlar quais outras classes podem estend√™-la.

<strong>Comportamento:</strong>
- Define explicitamente quem pode estender a 
classe.
- Introduzido no Java 15 como preview, e
  estabilizado no Java 17.

<strong>Palavras-chave:</strong>
- <em>sealed</em> ‚Üí indica que a classe √© selada.
- <em>permits</em> ‚Üí define as classes que podem 
estend√™-la.
- <em>non-sealed</em> ‚Üí uma subclasse que remove 
a restri√ß√£o.
- <em>final</em> ‚Üí subclasse que n√£o pode ser 
estendida.
- <em>sealed</em> ‚Üí subclasse que tamb√©m restringe 
quem pode estend√™-la.

<strong>Exemplo:</strong>

public sealed class Forma permits Circulo, Retangulo { }

public final class Circulo extends Forma {
    // n√£o pode ser estendida
}

public non-sealed class Retangulo extends Forma {
    // pode ser estendida por outras classes
}

<strong>Vantagens:</strong>
- Maior controle da hierarquia de classes.
- Seguran√ßa e previsibilidade ao modelar APIs.
- Ajuda o compilador e ferramentas est√°ticas a 
entender o modelo de heran√ßa.

<strong>Regras:</strong>
- Todas as subclasses devem estar no mesmo 
arquivo ou ser compiladas juntas.
- Cada subclasse deve declarar se √© sealed, 
non-sealed ou final.

</code>
        </pre>
      </div>
      <h2 class="section-title">üìò Tipos de M√©todos</h2>      
      
      <div class="block" data-tags="metodo-instancia">
        <div class="title">M√©todo de Inst√¢ncia</div>
        <pre>
<code>
class Pessoa {
  void falar() {
    System.out.println("Ol√°!");
  }
}

Pessoa p = new Pessoa();
p.falar();  // Ol√°!  
</code>
        </pre>
      </div>

      <div class="block" data-tags="metodo-estatico">
        <div class="title">M√©todo Est√°tico</div>
        <pre>
<code>
- Pode ser chamado sem instanciar a classe.

class Util {
    static int somar(int a, int b) {
        return a + b;
    }
}

int resultado = Util.somar(2, 3);  // 5  
</code>
        </pre>
      </div>

      <div class="block" data-tags="metodo-abstrato">
        <div class="title">M√©todo Abstrato</div>
        <pre>
<code>
- Declarado em classes abstratas. Sem corpo.
- Deve ser implementado por subclasses.

abstract class Animal {
    abstract void emitirSom();
}

class Gato extends Animal {
    void emitirSom() {
        System.out.println("Miau");
    }
}  
</code>
        </pre>
      </div>

      <div class="block" data-tags="metodo-final">
        <div class="title">M√©todo final</div>
        <pre>
<code>
- N√£o pode ser sobrescrito por subclasses.

class Pai {
    final void metodoImportante() {
        System.out.println("Importante!");
    }
}

class Filho extends Pai {
    // void metodoImportante() {} // ERRO!
}  
</code>
        </pre>
      </div>

      <div class="block" data-tags="metodo-sobrecarga">
        <div class="title">M√©todo Sobrecarga</div>
        <pre>
<code>
- V√°rios m√©todos com o mesmo nome, 
mas assinaturas diferentes.

class Calculadora {
    int somar(int a, int b) {
        return a + b;
    }

    double somar(double a, double b) {
        return a + b;
    }
}  
</code>
        </pre>
      </div>

      <div class="block" data-tags="metodo-sobrescrito">
        <div class="title">M√©todo Sobrescrito</div>
        <pre>
<code>
- Substitui o comportamento de um 
m√©todo herdado.

class Animal {
    void emitirSom() {
        System.out.println("Som");
    }
}

class Cachorro extends Animal {
    @Override
    void emitirSom() {
        System.out.println("Latido");
    }
}  
</code>
        </pre>
      </div>

      <div class="block" data-tags="metodo-privado">
        <div class="title">M√©todo Privado</div>
        <pre>
<code>
- S√≥ pode ser chamado dentro da pr√≥pria classe.

class Exemplo {
    private void metodoInterno() {
        System.out.println("Privado");
    }
}
</code>
        </pre>
      </div>

      <div class="block" data-tags="metodo-default">
        <div class="title">M√©todo Default em Interfaces</div>
        <pre>
<code>
- Introduzido no Java 8, permite que 
interfaces forne√ßam implementa√ß√µes padr√£o 
para m√©todos.
- Um m√©todo default tem um corpo e 
pode ser sobrescrito.

interface Animal {
  default void emitirSom() {
      System.out.println("Som gen√©rico");
  }
}

class Cachorro implements Animal {
  @Override
  public void emitirSom() {
      System.out.println("Latido");
  }
}  
</code>
        </pre>
      </div>

      <div class="block" data-tags="metodo varargd">
        <div class="title">M√©todo Varargs</div>
        <pre>
<code>
- Permite passar um n√∫mero vari√°vel de 
argumentos para o m√©todo.

class Matematica {
    void somar(int... numeros) {
        int soma = 0;
        for (int numero : numeros) {
            soma += numero;
        }
        System.out.println("Soma: " + soma);
    }
}

Matematica m = new Matematica();
m.somar(1, 2, 3, 4);  // Soma: 10
</code>
        </pre>
      </div>
      <!-- 
      <div class="block" data-tags="java-streams">
        <div class="title">Streams</div>
        <pre>
<code>
</code>
        </pre>
      </div>     
      -->
    
  </main>

  <script src="scripts.js"></script>
</body>
</html>
