<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Java QuickRef</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <header>
    <input
      type="text"
      id="filterInput"
      placeholder="Filtrar por palavra-chave..."
    />
  </header>

  <main id="grid">
    <h2 class="section-title">üìò B√°sico</h2>
    <!-- Bloco 1 -->
    <div class="block" data-tags="V√°riaveis">
      <div class="title">V√°riaveis</div>
        <button class="copy-btn">Copiar</button>
      <pre>
<code>
int num = 5;
float floatNum = 5.99f;
char letter = 'D';
boolean bool = true;
String site = "teste";
long idadeLong = 9223372036854775807L;
double peso = 70.5;
</code>
      </pre>
    </div>

    <div class="block wide" data-tags="tipos de dados primitivos">
        <div class="title">Tipos de Dados Primitivos</div>
        <div class="code-container">
          <table>
            <thead>
              <tr>
                <th>Tipo de Dado</th>
                <th>Tamanho</th>
                <th>Valor Default</th>
                <th>Range</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>byte</td>
                <td>8 bits</td>
                <td>0</td>
                <td>-128 a 127</td>
              </tr>
              <tr>
                <td>short</td>
                <td>16 bits</td>
                <td>0</td>
                <td>-32.768 a 32.767</td>
              </tr>
              <tr>
                <td>int</td>
                <td>32 bits</td>
                <td>0</td>
                <td>-2¬≥¬π a 2¬≥¬π-1</td>
              </tr>
              <tr>
                <td>long</td>
                <td>64 bits</td>
                <td>0L</td>
                <td>-2‚Å∂¬≥ a 2‚Å∂¬≥-1</td>
              </tr>
              <tr>
                <td>float</td>
                <td>32 bits</td>
                <td>0.0f</td>
                <td>¬±1.4E-45 a ¬±3.4E+38</td>
              </tr>
              <tr>
                <td>double</td>
                <td>64 bits</td>
                <td>0.0d</td>
                <td>¬±4.9E-324 a ¬±1.8E+308</td>
              </tr>
              <tr>
                <td>char</td>
                <td>16 bits</td>
                <td>'\u0000'</td>
                <td>'\u0000' a '\uffff'</td>
              </tr>
              <tr>
                <td>boolean</td>
                <td>1 bit (representado como 1 byte na pr√°tica)</td>
                <td>false</td>
                <td>true ou false</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

    <!-- Bloco 2 -->
    <div class="block" data-tags="Operadores Aritm√©ticos">
      <div class="title">Operadores Aritm√©ticos</div>
        <button class="copy-btn">Copiar</button>
<pre>
<code>
int a = 10;
int b = 3;

int soma = a + b;  // 13
int subtracao = a - b;  // 7
int multiplicacao = a * b;  // 30
int divisao = a / b;  // 3
int restoDaDivisao = a % b; // 1 
</code>
</pre>
    </div>

    <!-- Bloco 3 -->
    <div class="block" data-tags="Operadores de Atribui√ß√£o">
      <div class="title">Operadores de Atribui√ß√£o</div>
        <button class="copy-btn">Copiar</button>
<pre>
<code>
int x = 5;
x += 2; // x = x + 2
x -= 1; // x = x - 1
x *= 3; // x = x * 3
x /= 2; // x = x / 2
x %= 2; // x = x % 2
</code>
</pre>
    </div>
    
    <!-- Bloco 4 -->
    <div class="block" data-tags="Operadores Relacionais">
        <div class="title">Operadores Relacionais</div>
          <button class="copy-btn">Copiar</button>
<pre>
<code>
int a = 5, b = 10;

System.out.println(a == b); // false
System.out.println(a != b); // true
System.out.println(a > b);  // false
System.out.println(a < b);  // true
System.out.println(a >= b); // false
System.out.println(a <= b); // true
</code>
</pre>
      </div>

    <!-- Bloco 4 -->
    <div class="block" data-tags="Operadores L√≥gicos">
        <div class="title">Operadores L√≥gicos</div>
          <button class="copy-btn">Copiar</button>
<pre>
<code>
boolean cond1 = true;
boolean cond2 = false;

(cond1 && cond2); // false (E l√≥gico)
(cond1 || cond2); // true  (OU l√≥gico)
(!cond1);         // false (nega√ß√£o)
</code>
</pre>
    </div>

    <!-- Bloco 6 -->
    <div class="block" data-tags="Convers√£o Implicita">
        <div class="title">Convers√£o Implicita</div>
          <button class="copy-btn">Copiar</button>
<pre>
<code>
//Casting Implicito
//quando voc√™ est√° convertendo de um tipo 
//menor para um tipo maior, ou seja, 
//quando n√£o h√° risco de perda de dados.

// Convers√£o autom√°tica de int para double
int num = 10;
double valor = num;

</code>
</pre>
    </div>

    <!-- Bloco 6 -->
    <div class="block" data-tags="Convers√£o explicita">
        <div class="title">Convers√£o Explicita</div>
          <button class="copy-btn">Copiar</button>
<pre>
<code>
//Casting Explicito
//√â quando voc√™ precisa informar que
//quer converter, porque existe 
//risco de perder informa√ß√£o.

// Perde a parte decimal (resultado: 10)
double valorDecimal = 10.75;
int valorInteiro = (int) valorDecimal;

</code>
</pre>
    </div>

    <h2 class="section-title">üìò String</h2>

    <!-- Bloco 7 -->
    <div class="block" data-tags="Concatenando Strings">
        <div class="title">Concatenando Strings</div>
        <button class="copy-btn">Copiar</button>
<pre>
<code>
String nome = "Jo√£o";
String sobrenome = "Silva";
String nomeCompleto = nome + " " + sobrenome; // Jo√£o Silva

String concat = nome.concat(" Silva"); // Jo√£o Silva



</code>
</pre>
    </div>

    <!-- Bloco 8 -->
    <div class="block" data-tags="Comparando Strings">
        <div class="title">Comparando Strings</div>
        <button class="copy-btn">Copiar</button>
<pre>
<code>
String str1 = "Java";
String str2 = "java";
boolean iguais = str1.equals(str2); // false

//Compara√ß√£o sem diferenciar min√∫scula de maiuscula
boolean iguaisIgnoreCase = str1.equalsIgnoreCase(str2); // true


</code>
</pre>
    </div>

    <!-- Bloco 9 -->
    <div class="block" data-tags="string manipula√ß√£o texto">
        <div class="title">Substituindo em String</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
String frase = "Eu amo Java";
String novaFrase = frase.replace("Java", "Python"); // Eu amo Python

//remove pontos e tra√ßos
String message = "000-123-4567 or 000.123.4567";
String normalizedMessage = message.replaceAll("[.-]", "");
System.out.println(normalizedMessage);
</code>
        </pre>
    </div>

    
<!-- Bloco: Obtendo comprimento da String -->
    <div class="block" data-tags="string comprimento texto">
        <div class="title">Obtendo Comprimento da String</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
String texto = "Java";
int comprimento = texto.length(); // 4
</code>
        </pre>
    </div>

<!-- Bloco: Extraindo parte da String -->
    <div class="block" data-tags="string substring manipula√ß√£o texto">
        <div class="title">Extraindo Parte da String</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
String frase = "Eu amo programa√ß√£o";
String parte = frase.substring(3, 6); // "amo"
</code>
        </pre>
    </div>

<!-- Bloco: Convertendo para mai√∫sculas ou min√∫sculas -->
    <div class="block" data-tags="string mai√∫scula min√∫scula texto">
        <div class="title">Convertendo para Mai√∫sculas ou Min√∫sculas</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
String texto = "java";
String maiusculo = texto.toUpperCase(); // "JAVA"
String minusculo = texto.toLowerCase(); // "java"
</code>
        </pre>
    </div>

<!-- Bloco: Verificando in√≠cio ou fim da String -->
    <div class="block" data-tags="string startwith endswith texto">
        <div class="title">Verificando In√≠cio ou Fim da String</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
String frase = "Java √© poderoso";
boolean comecaComJava = frase.startsWith("Java"); // true
boolean terminaComPoderoso = frase.endsWith("poderoso"); // true
</code>
        </pre>
    </div>

<!-- Bloco: Removendo espa√ßos em branco -->
    <div class="block" data-tags="string trim espa√ßo texto">
        <div class="title">Removendo Espa√ßos em Branco</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
String frase = "  Ol√°, Mundo!  ";
String limpa = frase.trim(); // "Ol√°, Mundo!"
</code>
        </pre>
    </div>

<!-- Bloco: Dividindo a String -->
    <div class="block" data-tags="string split dividir texto">
        <div class="title">Dividindo a String</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
String frase = "ma√ß√£,banana,laranja";
String[] frutas = frase.split(","); // ["ma√ß√£", "banana", "laranja"]
</code>

        </pre>
    </div>

<!-- Bloco: Verificando se cont√©m uma substring -->
    <div class="block" data-tags="string contains substring texto">
        <div class="title">Verificando se Cont√©m uma Substring</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
String frase = "Eu gosto de Java";
boolean temJava = frase.contains("Java"); // true
</code>

        </pre>
    </div>

<!-- Bloco: Substituindo em Strings -->
    <div class="block" data-tags="string replace manipula√ß√£o texto">
        <div class="title">Verificando se a String esta vazia</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
String frase = "abcd"
frase.isEmpty();      //false
</code>

        </pre>
    </div>

<!-- Bloco: Comparando Strings -->
    <div class="block" data-tags="string compareTo compara√ß√£o texto">
        <div class="title">Comparando Strings</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
String str1 = "Java";
String str2 = "JavaScript";
int resultado = str1.compareTo(str2); // Valor < 0, pois "Java" vem antes de "JavaScript"
</code>
        </pre>
    </div>

    <!-- Bloco: charAt -->
    <div class="block" data-tags="string charAt caractere √≠ndice">
        <div class="title">Obtendo um Caractere com charAt</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
String palavra = "banana";
char letra = palavra.charAt(2); // 'n'
</code>
        </pre>
    </div>
  
  <!-- Bloco: indexOf -->
    <div class="block" data-tags="string indexOf posi√ß√£o encontrar">
        <div class="title">Encontrando Substring com indexOf</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
String texto = "Eu gosto de Java";
int indice = texto.indexOf("Java"); // 12
</code>
        </pre>
    </div>

    <!-- Bloco: Conversao -->
    <div class="block" data-tags="string indexOf posi√ß√£o encontrar">
        <div class="title">Convertendo para String</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
int valor = 12;
String num = String.valueOf(valor); // "12"
</code>
        </pre>
    </div>
    
    <h2 class="section-title">üìò StringBuilder</h2>

    <!-- Bloco: Criando e adicionando texto -->
    <div class="block" data-tags="stringbuilder append criar adicionar">
        <div class="title">Criando e Adicionando Texto</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
StringBuilder sb = new StringBuilder();
sb.append("Ol√°");
sb.append(" Mundo!");
System.out.println(sb.toString()); // Ol√° Mundo!
</code>
        </pre>
    </div>
  
  <!-- Bloco: Inserindo texto -->
    <div class="block" data-tags="stringbuilder insert inserir">
        <div class="title">Inserindo Texto</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
StringBuilder sb = new StringBuilder("Java √© legal");
sb.insert(5, "muito ");
System.out.println(sb.toString()); // Java muito √© legal
</code>

        </pre>
    </div>
  
  <!-- Bloco: Substituindo texto -->
    <div class="block" data-tags="stringbuilder replace substituir">
        <div class="title">Substituindo Texto</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
StringBuilder sb = new StringBuilder("Ol√° Mundo");
sb.replace(4, 9, "Java");
System.out.println(sb.toString()); // Ol√° Java
</code>
    
        </pre>
    </div>
  
  <!-- Bloco: Deletando texto -->
    <div class="block" data-tags="stringbuilder delete deletar remover">
        <div class="title">Removendo Parte do Texto</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
StringBuilder sb = new StringBuilder("Remover isso");
sb.delete(8, 13);
System.out.println(sb.toString()); // Remover
</code>
        </pre>
    </div>
  
  <!-- Bloco: Revertendo texto -->
    <div class="block" data-tags="stringbuilder reverse inverter">
        <div class="title">Invertendo Texto</div>
        <button class="copy-btn">Copiar</button>
        <pre>
<code>
StringBuilder sb = new StringBuilder("abc");
sb.reverse();
System.out.println(sb.toString()); // cba
</code>
        </pre>
    </div>
    
    <h2 class="section-title">üìò Integer</h2>

    <!-- Bloco: Convertendo String para Integer -->
    <div class="block" data-tags="integer parseint converter string inteiro">
      <div class="title">Convertendo String para Integer</div>
      <button class="copy-btn">Copiar</button>
      <pre>
<code>
String valor = "123";
int numero = Integer.parseInt(valor);
System.out.println(numero); // 123
</code>
      </pre>
    </div>

    <!-- Bloco: Convertendo Integer para String -->
    <div class="block" data-tags="integer tostring converter inteiro string">
      <div class="title">Convertendo Integer para String</div>
      <button class="copy-btn">Copiar</button>
      <pre>
<code>
int numero = 456;
String texto = Integer.toString(numero);
System.out.println(texto); // "456"
</code>
      </pre>
    </div>

<!-- Bloco: Comparando inteiros -->
    <div class="block" data-tags="integer compare comparar equals">
      <div class="title">Comparando Inteiros</div>
      <button class="copy-btn">Copiar</button>
      <pre>
<code>
Integer a = 10;
Integer b = 20;

System.out.println(a.equals(b)); // false

// 0 se a for igual a b
// -1 se a for menor que b
// 1 se a for maior que b

System.out.println(Integer.compare(a, b)); // -1
</code>
      </pre>
    </div>

    <!-- Bloco: Convertendo para bin√°rio, octal e hexadecimal -->
    <div class="block" data-tags="integer bin√°rio octal hexadecimal tobinarystring">
      <div class="title">Bin√°rio, Octal e Hexadecimal</div>
      <button class="copy-btn">Copiar</button>
      <pre>
<code>
int numero = 42;

System.out.println(Integer.toBinaryString(numero)); // 101010
System.out.println(Integer.toOctalString(numero));  // 52
System.out.println(Integer.toHexString(numero));    // 2a
</code>
      </pre>
    </div>

    <!-- Bloco: Valor m√°ximo e m√≠nimo -->
    <div class="block" data-tags="integer max min limite valor m√°ximo m√≠nimo">
      <div class="title">Valor M√°ximo e M√≠nimo</div>
      <button class="copy-btn">Copiar</button>
      <pre>
<code>
System.out.println(Integer.MAX_VALUE); // 2147483647
System.out.println(Integer.MIN_VALUE); // -2147483648



</code>
      </pre>
    </div>

    <h2 class="section-title">üìò Double</h2>

<!-- Bloco 1 - Cria√ß√£o e m√©todos b√°sicos -->
    <div class="block" data-tags="double wrapper parsevalue valor toString isNaN isInfinite">
      <div class="title">Double - M√©todos e Opera√ß√µes</div>
      <button class="copy-btn">Copiar</button>
      <pre>
<code>
// Criando objetos Double
Double d1 = 10.5;
Double d2 = Double.valueOf("20.5");

// Compara√ß√µes
// 0 se a for igual a b
// -1 se a for menor que b
// 1 se a for maior que b

System.out.println(Double.compare(d1, d2)); // -1

// Verifica√ß√µes
System.out.println(Double.isNaN(d1));      // false
System.out.println(Double.isInfinite(d1)); // false

// Convers√µes
double valor = d1.doubleValue();         // 10.5
String texto = d1.toString();            // "10.5"
Double d3 = Double.parseDouble("30.25"); // 30.25
</code>
      </pre>
    </div>

<!-- Bloco 2 - Constantes e limites -->
    <div class="block" data-tags="double constante valor maximo minimo positivo infinito negativo">
      <div class="title">Double - Constantes</div>
      <button class="copy-btn">Copiar</button>
      <pre>
<code>
System.out.println(Double.MAX_VALUE);  // Maior valor positivo
System.out.println(Double.MIN_VALUE);  // Menor valor positivo

System.out.println(Double.POSITIVE_INFINITY); // Infinito positivo
System.out.println(Double.NEGATIVE_INFINITY); // Infinito negativo
System.out.println(Double.NaN);              // Not-a-Number
</code>
    </pre>
    </div>

    <h2 class="section-title">üìò BigDecimal</h2>

    <div class="block" data-tags="bigdecimal soma add">
      <div class="title">BigDecimal - Opera√ß√µes</div>
      <pre>
<code>
Soma  
BigDecimal a = new BigDecimal("10.50");
BigDecimal b = new BigDecimal("5.25");
BigDecimal resultado = a.add(b); // 15.75

// Subtra√ß√£o
BigDecimal a = new BigDecimal("10.50");
BigDecimal b = new BigDecimal("5.25");
BigDecimal resultado = a.subtract(b); // 5.25

//Multiplica√ß√£o
BigDecimal preco = new BigDecimal("2.50");
BigDecimal quantidade = new BigDecimal("4");
BigDecimal total = preco.multiply(quantidade); // 10.00

//Divis√£o
<strong>Sempre defina o modo de arredondamento ao dividir.</strong>
import java.math.RoundingMode;
BigDecimal total = new BigDecimal("10");
BigDecimal partes = new BigDecimal("3");
BigDecimal resultado = total.divide(partes, 2, RoundingMode.HALF_UP); // 3.33
</code>


      </pre>
    </div>

    <div class="block" data-tags="bigdecimal comparar compareTo">
      <div class="title">Compara dois BigDecimal</div>
      <pre>
<code>
BigDecimal a = new BigDecimal("10.00");
BigDecimal b = new BigDecimal("10");

// 0 se a for igual a b
// -1 se a for menor que b
// 1 se a for maior que b
if (a.compareTo(b) == 0) {
  System.out.println("S√£o iguais");
}

</code>
      </pre>
      <div class="title">Retorna o maior valor</div>
      <pre>
<code>
BigDecimal a = new BigDecimal("10");
BigDecimal b = new BigDecimal("20");
BigDecimal maior = a.max(b); // 20  
</code>
      </pre>
      <div class="title">Define casas decimais com arredondamento</div>
      <pre>
<code>
BigDecimal valor = new BigDecimal("3.14159");
BigDecimal arredondado = valor.setScale(2, RoundingMode.HALF_UP); // 3.14  
</code>
      </pre>
    </div>

    <div class="block" data-tags="bigdecimal zeros stripTrailingZeros">
      <div class="title">Remove zeros desnecess√°rios</div>
      <pre>
<code>
BigDecimal valor = new BigDecimal("10.000");
valor = valor.stripTrailingZeros(); // 1E+1
</code>
      </pre>
      <div class="title">Exibe o n√∫mero em formato normal</div>
      <pre>
<code>
BigDecimal valor = new BigDecimal("1.00E+2");
valor.toPlainString(); // "100"
</code>
      </pre>
      <div class="title">Retorna o resto da divis√£o</div>
      <pre>
<code>
BigDecimal a = new BigDecimal("10");
BigDecimal b = new BigDecimal("3");
BigDecimal resto = a.remainder(b); // 1
</code>
      </pre>
      <div class="title">Retorna o valor absoluto</div>
      <pre>
<code>
BigDecimal negativo = new BigDecimal("-25.5");
BigDecimal absoluto = negativo.abs(); // 25.5
</code>
      </pre>
    </div>

    <div class="block" data-tags="bigdecimal zeros stripTrailingZeros">
      <div class="title">Retorna o menor valor</div>
      <pre>
<code>
BigDecimal a = new BigDecimal("10");
BigDecimal b = new BigDecimal("20");
BigDecimal menor = a.min(b); // 10
</code>
      </pre>
      <div class="title">Converte para tipos primitivos</div>
      <pre>
<code>
BigDecimal valor = new BigDecimal("123.45");
double d = valor.doubleValue();
int i = valor.intValue(); // 123
Long l = valor.longValue();
</code>
      </pre>
    </div>

    <div class="block" data-tags="bigdecimal zeros stripTrailingZeros">
      <div class="title">Move a v√≠rgula n casas pra esquerda</div>
      <pre>
<code>
BigDecimal valor = new BigDecimal("12345");
valor = valor.movePointLeft(2); // 123.45  
</code>
      </pre>
    </div>

    <div class="block" data-tags="bigdecimal zeros stripTrailingZeros">
      <div class="title">Move a v√≠rgula n casas pra direita</div>
      <pre>
<code>
BigDecimal valor = new BigDecimal("123.45");
valor = valor.movePointRight(2); // 12345    
</code>
      </pre>
    </div>

    <h2 class="section-title">Datas com java.time (Java 8+)</h2>

    <div class="block" data-tags="java.time">
      <div class="title">Trabalhando com datas - LocalDate</div>
      <pre>
<code>
<strong>Retorna a data atual sem hora.</strong>
LocalDate.now() //2025-04-17

<strong>Converte uma string padr√£o ISO para uma data.</strong>
LocalDate.parse("2025-04-13") //2025-04-13

<strong>Cria uma data com ano, m√™s e dia.</strong>
LocalDate.of(2025, 4, 13) //2025-04-13

<strong>Formata uma data com padr√£o personalizado.</strong>
LocalDate
  .format(
    DateTimeFormatter.ofPattern("dd/MM/yyyy"))

<strong>Converte uma string para LocalDate 
  com um padr√£o personalizado.</strong>
LocalDate
  .parse(
    "13/04/2025", 
    DateTimeFormatter.ofPattern("dd/MM/yyyy"))

</code>
      </pre>
    </div>

    <div class="block" data-tags="java.time">
      <div class="title">Trabalhando com datas - LocalDate</div>
      <pre>
<code>
LocalDate hoje = LocalDate.now(); // data atual
<strong>Soma 7 dias √† data.</strong>
LocalDate daquiASeteDias = hoje.plusDays(7);

<strong>Subtrai 7 dias √† data.</strong>
LocalDate SeteDiasAtras = hoje.minusDays(7);  

<strong>Adiciona 1 m√™s √† data.</strong>
LocalDate daquiUmMes = hoje.plusMonths(1);

<strong>Subtrai 1 m√™s da data atual</strong>
LocalDate haUmMesAtras = hoje.minusMonths(1);
</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.time">
      <div class="title">Trabalhando com datas - LocalDate</div>
      <pre>
<code>
// data atual  
LocalDate hoje = LocalDate.now();  
<strong>Adiciona 1 semana √† data atual</strong>
LocalDate daquiUmaSemana = hoje.plusWeeks(1);

<strong>Subtrai 1 semana da data atual</strong>
LocalDate umaSemanaAtras = hoje.minusWeeks(1);

<strong>Adiciona 1 ano √† data atual</strong>
LocalDate daqui1Ano = hoje.plusYears(1);  
</code>
      </pre>
    </div>

    <div class="block" data-tags="java.time">
      <div class="title">Trabalhando com datas - LocalDate</div>
      <pre>
<code>
<strong>Adiciona 1 ano √† data atual</strong>
LocalDate ha1AnoAtras = hoje.minusYears(1);

<strong>Altera o dia de uma data</strong>
LocalDate setDia = hoje.withDayOfMonth(1);

<strong>Altera o m√™s de uma data</strong>
LocalDate setaMes = hoje.withMonth(1);

<strong>Altera o ano de uma data</strong>
LocalDate setAno = hoje.withYear(1);

<strong>Altera uma data de acordo com o dia do ano</strong>
LocalDate setDiaAno = hoje.withDayOfYear(90);
</code>
      </pre>
    </div>

    <div class="block" data-tags="java.time">
      <div class="title">Trabalhando com datas - LocalDate</div>
      <pre>
<code>
<strong>Converte LocalDate para LocalDatetime e 
  adiciona o minuto e segundo como 0</strong>

  // 2025-04-13T00:00
LocalDateTime dataHora = data.atStartOfDay();

<strong>Setar uma hora especifica em um LocalDate</strong>
// 15:30 (3:30 da tarde)
LocalDateTime dataHora = data.atTime(15, 30);

<strong>Jeitos de comparar datas com LocalDate</strong>
LocalDate data1 = LocalDate.of(2025, 4, 13);
LocalDate data2 = LocalDate.of(2025, 4, 10);

//Retorna 0 se valor1 √© igual a valor2
//Retorna > 0 se valor1 √© maior que valor2
//Retorna < 0 se valor1 √© menor que valor2
int resultado = data1.compareTo(data2);  
</code>
       </pre>
    </div>

    <div class="block" data-tags="java.time">
      <div class="title">Trabalhando com datas - LocalDate</div>
      <pre>
<code>
<strong>Retorna todas as datas entre as informadas</strong>
LocalDate start = LocalDate.of(2025, 4, 1);
LocalDate end = LocalDate.of(2025, 4, 5);

start
  .datesUntil(end)
  .forEach(System.out::println);

<strong>Verificar se uma data vem ap√≥s a outra</strong>
LocalDate hoje = LocalDate.now();
LocalDate ontem = hoje.minusDays(1);

hoje.isAfter(ontem); // true
ontem.isAfter(hoje); // false

<strong>Verificar se uma data vem antes da outra</strong>
LocalDate hoje = LocalDate.now();
LocalDate ontem = hoje.minusDays(1);

hoje.isBefore(ontem); // false
ontem.isBefore(hoje); // true

<strong>Verificar se uma data √© igual a outra</strong>
hoje.isEqual(hoje); //true

</code>
       </pre>
    </div>

    <div class="block" data-tags="java.time">
      <div class="title">Per√≠odo entre datas</div>
      <pre>
<code>
LocalDate inicio = LocalDate.of(2024, 1, 1);
LocalDate fim = LocalDate.of(2025, 4, 13);

Period periodo = Period.between(inicio, fim);
System.out.println(periodo.getYears());   // 1
System.out.println(periodo.getMonths());  // 3
System.out.println(periodo.getDays());    // 12
</code>
      </pre>
    </div>

    <div class="block" data-tags="java.time">
      <div class="title">Dura√ß√£o</div>
      <pre>
<code>
LocalDateTime inicio = LocalDateTime.of(2024, 4, 12, 14, 0);
LocalDateTime fim = LocalDateTime.of(2024, 4, 13, 18, 30);
  
Duration duracao = Duration.between(inicio, fim);
System.out.println(duracao.toHours());   // 28
System.out.println(duracao.toMinutes()); // 1710
System.out.println(duracao.getSeconds());// 102600
</code>
      </pre>
    </div>

    <div class="block" data-tags="java.time">
      <div class="title">Per√≠odo entre datas</div>
      <pre>
<code>
LocalDate inicio = LocalDate.of(2023, 10, 1);
LocalDate fim = LocalDate.of(2025, 4, 13);

long dias = ChronoUnit.DAYS.between(inicio, fim);
long meses = ChronoUnit.MONTHS.between(inicio, fim);
long anos = ChronoUnit.YEARS.between(inicio, fim);

System.out.println("Dias: " + dias);
System.out.println("Meses: " + meses);
System.out.println("Anos: " + anos);
</code>
      </pre>
    </div>

    <div class="block" data-tags="java.time">
      <div class="title">Trabalhando com fuso hor√°rio</div>
      <pre>
<code>
<strong>Use ZonedDateTime se quiser manter a no√ß√£o 
de fuso com regi√£o (ex: "America/Sao_Paulo").</strong>  

ZonedDateTime agoraSP = ZonedDateTime
  .now(ZoneId.of("America/Sao_Paulo"));

<strong>Use OffsetDateTime se quiser apenas 
o deslocamento (ex: "-03:00").</strong>

OffsetDateTime agoraOffset = OffsetDateTime
  .now(ZoneOffset.of("-03:00"));

<strong>Instant representa um ponto no tempo 
UTC (sem fuso). Ideal para salvar 
em banco de dados  
</strong>
Instant agora = Instant.now();

// Converter para exibi√ß√£o no fuso do usu√°rio
ZonedDateTime dataLocal = agora
  .atZone(ZoneId.of("America/Sao_Paulo"));

</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.time">
      <div class="title">ZonedDateTime - Convers√£o para outras classes</div>
      <pre>
<code>
ZonedDateTime agora = ZonedDateTime
  .now(ZoneId.of("America/Sao_Paulo"));  

// Para salvar em banco como UTC
Instant instant = agora.toInstant();

// S√≥ a data
LocalDate local = agora.toLocalDate();

// S√≥ a hora
LocalTime hora = agora.toLocalTime();

ZoneOffset offset = agora.getOffset();
</code>
      </pre>
    </div>

    <div class="block" data-tags="java.time">
      <div class="title">OffsetDateTime - Convers√£o para outras classes</div>
      <pre>
<code>
OffsetDateTime agora = OffsetDateTime.now();  

// De ZonedDateTime para OffsetDateTime
ZonedDateTime zdt = ZonedDateTime
  .now(ZoneId.of("America/Sao_Paulo"));

  OffsetDateTime odt = zdt.toOffsetDateTime();

// De LocalDateTime com offset
LocalDateTime ldt = LocalDateTime.now();

OffsetDateTime odt2 = ldt
  .atOffset(ZoneOffset.of("-03:00"));
</code>
      </pre>
    </div>
      
    <h2 class="section-title">üìò Arrays</h2>  

    <div class="block wide" data-tags="tipos de dados primitivos">
      <div class="title">Pilhas, Filas e Collections</div>
      <div class="code-container">
        <table>
          <thead>
            <tr>
              <th>Tipo</th>
              <th>Interface Base</th>
              <th>Vantagens</th>
              <th>Desvantagens</th>
              <th>Quando Usar</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>List</td>
              <td>ArrayList</td>
              <td>Ordem de inser√ß√£o, acesso por √≠ndice, permite duplicados</td>
              <td>R√°pido para leitura</td>
              <td>Lento para inser√ß√µes/remo√ß√µes no meio</td>
            </tr>
            <tr>
              <td>List</td>
              <td>LinkedList</td>
              <td>Lista duplamente ligada</td>
              <td>R√°pido para inser√ß√µes/remo√ß√µes</td>
              <td>Mais lenta para acesso aleat√≥rio</td>
            </tr>
        
            <!-- STACK -->
            <tr>
              <td>Stack</td>
              <td>Stack</td>
              <td>Pilha (LIFO)</td>
              <td>Ideal para algoritmos recursivos</td>
              <td>Baseada em vetor, performance pode variar</td>
            </tr>
            <tr>
              <td>Stack</td>
              <td>Deque como pilha (ArrayDeque)</td>
              <td>Melhor alternativa moderna</td>
              <td>Mais r√°pido que Stack</td>
              <td>Sem sincroniza√ß√£o</td>
            </tr>
        
            <!-- QUEUE -->
            <tr>
              <td>Queue</td>
              <td>LinkedList</td>
              <td>Fila (FIFO), permite nulo</td>
              <td>Simples e vers√°til</td>
              <td>N√£o especializada</td>
            </tr>
            <tr>
              <td>Queue</td>
              <td>ArrayDeque</td>
              <td>Fila sem sincroniza√ß√£o</td>
              <td>Alta performance</td>
              <td>N√£o permite elementos nulos</td>
            </tr>
            <tr>
              <td>Queue</td>
              <td>PriorityQueue</td>
              <td>Ordena por prioridade</td>
              <td>√ìtimo para algoritmos</td>
              <td>Sem ordem previs√≠vel de inser√ß√£o</td>
            </tr>
            <tr>
              <td>Queue</td>
              <td>ConcurrentLinkedQueue</td>
              <td>Fila n√£o bloqueante (concorrente)</td>
              <td>Thread-safe</td>
              <td>Uso avan√ßado</td>
            </tr>
        
            <!-- SET -->
            <tr>
              <td>Set</td>
              <td>HashSet</td>
              <td>Sem ordem, sem duplicados</td>
              <td>Alta performance</td>
              <td>Ordem imprevis√≠vel</td>
            </tr>
            <tr>
              <td>Set</td>
              <td>LinkedHashSet</td>
              <td>Ordem de inser√ß√£o, sem duplicados</td>
              <td>Previsibilidade</td>
              <td>Mais lento que HashSet</td>
            </tr>
            <tr>
              <td>Set</td>
              <td>TreeSet</td>
              <td>Ordenado, sem duplicados</td>
              <td>Ordena√ß√£o natural ou personalizada</td>
              <td>Mais lento</td>
            </tr>
            <tr>
              <td>Set</td>
              <td>EnumSet</td>
              <td>Especializado para enums</td>
              <td>Leve e eficiente</td>
              <td>Somente enums</td>
            </tr>
        
            <!-- MAP -->
            <tr>
              <td>Map</td>
              <td>HashMap</td>
              <td>Chave-valor, sem ordem</td>
              <td>Alta performance</td>
              <td>Sem ordem previs√≠vel</td>
            </tr>
            <tr>
              <td>Map</td>
              <td>LinkedHashMap</td>
              <td>Chave-valor, ordem de inser√ß√£o</td>
              <td>Boa previsibilidade</td>
              <td>Mais lento</td>
            </tr>
            <tr>
              <td>Map</td>
              <td>TreeMap</td>
              <td>Chave-valor ordenado</td>
              <td>Ordena√ß√£o por chave</td>
              <td>Mais pesado</td>
            </tr>
            <tr>
              <td>Map</td>
              <td>EnumMap</td>
              <td>Chave do tipo enum</td>
              <td>Leve e r√°pido</td>
              <td>Somente enums</td>
            </tr>
            <tr>
              <td>Map</td>
              <td>ConcurrentHashMap</td>
              <td>Thread-safe</td>
              <td>Concorr√™ncia sem bloqueio</td>
              <td>Uso mais complexo</td>
            </tr>
        
            <!-- OUTROS -->
            <tr>
              <td>Outros</td>
              <td>Collections.synchronizedList</td>
              <td>Lista sincronizada</td>
              <td>Thread-safe</td>
              <td>Mais lenta</td>
            </tr>
            <tr>
              <td>Outros</td>
              <td>Collections.unmodifiableList</td>
              <td>Lista imut√°vel</td>
              <td>Seguran√ßa em APIs p√∫blicas</td>
              <td>N√£o pode ser alterada</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>  

    <div class="block" data-tags="java.time">
      <div class="title">ArrayList</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Acesso r√°pido por √≠ndice
- Boa performance para leitura sequencial
- Permite duplicatas e elementos null

<strong>Desvantagens</strong>
- Inser√ß√£o/remo√ß√£o lenta no in√≠cio ou meio da lista
- Redimensionamento pode ser custoso
- N√£o √© thread-safe
- Capacidade predefinida pode causar desperd√≠cio

ArrayList<String> nomes = new ArrayList<>();

<strong>Adicionando elementos</strong>
nomes.add("Ana");
nomes.add("Carlos");
// Inserindo "Laranja" na posi√ß√£o 2
nomes.add(2, "Laranja");

<strong>Outra forma de inicializar</strong>
List<String> lista = new ArrayList<>(
  List.of("Ma√ß√£", "Banana", "Laranja"));


<strong>Acessando por √≠ndice</strong>
System.out.println(nomes.get(1)); // Carlos

<strong>Retorna o √≠ndice</strong>
// 1, se n√£o existir retorna -1
System.out.println(lista.indexOf("Carlos"));

<strong>Retorna o √≠ndice da √∫ltima 
ocorr√™ncia</strong>
System.out.println(lista.lastIndexOf("A"));

<strong>Tamanho da lista</strong>
System.out.println(nomes.size()); // 3

<strong>Remover por √≠ndice ou valor</strong>
nomes.remove(0); // Remove "Ana" (√≠ndice 0)
nomes.remove("Carlos");

<strong>Substituindo o elemento no √≠ndice 1</strong>
nomes.set(1, "Julio");

<strong>Retorna uma sublista da lista original</strong>
List<String> sublista = lista.subList(2, 3);
System.out.println(sublista); // [Carlos, Laranja]

<strong>Verificar se cont√©m um elemento</strong>
if (nomes.contains("Ana")) {
    System.out.println("Ana est√° na lista.");
}

<strong>Iterar</strong>
for (String nome : nomes) {
    System.out.println(nome);
}

<strong>Limpa a lista</strong>
nomes.clear();

<strong>Verificar se a lista esta vazia</strong>

System.out.println(nomes.isEmpty()); //true
</code>
      </pre>
    </div>

    <div class="block" data-tags="java.time">
      <div class="title">LinkedList</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Inser√ß√µes e remo√ß√µes eficientes
- Implementa v√°rias interfaces List, Deque (fila dupla), e Queue
- Permite elementos duplicados e nulos

<strong>Desvantagens</strong>
- Acesso aleat√≥rio lento 
- Maior consumo de mem√≥ria
- Em opera√ß√µes que iteram muitos elementos sequencialmente, 
ArrayList tende a ser mais r√°pido por usar um array cont√≠nuo
- N√£o √© thread-safe

LinkedList<String> nomes = new LinkedList<>();

<strong>Adicionando elementos</strong>
nomes.add("Ana");
nomes.add("Carlos");
nomes.addFirst("Jo√£o"); // Adiciona no in√≠cio da lista
nomes.addLast("Maria"); // Adiciona no final da lista

<strong>Outra forma de inicializar</strong>
List<String> lista = new LinkedList<>(
  List.of("Ma√ß√£", "Banana", "Laranja"));

<strong>Cria uma sublista dos elementos de 
√≠ndice 1 at√© 3 (n√£o inclui o 4)</strong>

List<String> sublista = nomes.subList(1, 4);
System.out.println(sublista); // [Carlos, Jo√£o, Maria]  

<strong>Acessando por √≠ndice</strong>
System.out.println(nomes.get(1)); // Carlos

<strong>Remover elementos</strong>
nomes.remove(0); // Remove "Jo√£o" (√≠ndice 0)
nomes.removeFirst(); // Remove o primeiro elemento
nomes.removeLast(); // Remove o √∫ltimo elemento

<strong>Substituindo o elemento no √≠ndice 1</strong>
nomes.set(1, "Julio");

<strong>Verificar se cont√©m um elemento</strong>
if (nomes.contains("Carlos")) {
    System.out.println("Carlos est√° na lista.");
}

<strong>Iterar</strong>
for (String nome : nomes) {
    System.out.println(nome);
}

<strong>Limpa a lista</strong>
nomes.clear();

<strong>Verificar se a lista est√° vazia</strong>
System.out.println(nomes.isEmpty()); //true

<strong>Adicionar um elemento na frente ou no final</strong>
nomes.addFirst("Novo Primeiro");
nomes.addLast("Novo √öltimo");

<strong>Retornar o primeiro e √∫ltimo elemento</strong>
System.out.println("Primeiro: " + nomes.getFirst());
System.out.println("√öltimo: " + nomes.getLast());
</code>
      </pre>
    </div>

    <div class="block" data-tags="java.time">
      <div class="title">Stack</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Herdando de Vector, todos os m√©todos p√∫blicos s√£o sincronizados. 
Pode ser √∫til em ambientes multithreaded simples.
- Inclui m√©todos de busca

<strong>Desvantagens</strong>  
- Internamente usa Vector, que √© considerado antiquado e 
menos eficiente que estruturas mais modernas, como ArrayDeque.
- Por causa da sincroniza√ß√£o e da heran√ßa de Vector, o Stack 
tem desempenho inferior ao ArrayDeque em contextos de thread √∫nica.
- Usado apenas como pilha; n√£o funciona bem como fila ou deque

Stack<String> pilha = new Stack<>();

<strong>Empilhando elementos</strong>
pilha.push("Ana");
pilha.push("Carlos");
pilha.push("Jo√£o");

<strong>Buscar a posi√ß√£o de um elemento</strong>
System.out.println(pilha.search("Carlos")); // 1 

<strong>Verificando o elemento no topo da pilha</strong>
System.out.println(pilha.peek()); // Jo√£o

<strong>Remover o elemento do topo da pilha</strong>
System.out.println(pilha.pop()); // Jo√£o (removido)
System.out.println(pilha.pop()); // Carlos (removido)

<strong>Verificando se a pilha est√° vazia</strong>
System.out.println(pilha.isEmpty()); // false

<strong>Verificando o tamanho da pilha</strong>
System.out.println(pilha.size()); // 1

<strong>Empilhar mais um elemento</strong>
pilha.push("Maria");

<strong>Verificando se a pilha cont√©m um elemento</strong>
System.out.println(pilha.contains("Ana")); // false

<strong>Iterando sobre os elementos da pilha</strong>
for (String nome : pilha) {
    System.out.println(nome);
}

// Sa√≠da:
// Ana
// Maria

<strong>Limpar a pilha</strong>
pilha.clear();
System.out.println(pilha.isEmpty()); // true
</code>
      </pre>
    </div>

    <div class="block" data-tags="java.time">
      <div class="title">ArrayDeque</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Alta performance de Inser√ß√µes e remo√ß√µes nas extremidades
- Mais r√°pido que Stack e LinkedList
- Pode ser usado como fila e pilha

<strong>Desvantagens</strong>
- N√£o permite elementos nulos
- N√£o √© thread-safe
- N√£o tem acesso aleat√≥rio por √≠ndice

Deque<String> deque = new ArrayDeque<>();

<strong>Adicionando elementos</strong>
deque.add("Ana");
deque.add("Carlos");
deque.add("Jo√£o");

<strong>Inserir no in√≠cio da deque</strong>
deque.addFirst("Maria");

<strong>Inserir no final da deque</strong>
deque.addLast("Jo√£o");

<strong>Remover elementos</strong>
System.out.println(deque.removeFirst()); // Maria
System.out.println(deque.removeLast());  // Jo√£o

<strong>Acessando elementos</strong>
System.out.println(deque.getFirst()); // Ana
System.out.println(deque.getLast());  // Jo√£o

<strong>Verificando se a deque cont√©m um elemento</strong>
System.out.println(deque.contains("Carlos")); // true
System.out.println(deque.contains("Ana"));    // true

<strong>Remover um elemento espec√≠fico</strong>
deque.remove("Carlos");

<strong>Verificando o tamanho da deque</strong>
System.out.println(deque.size()); // 2

<strong>Iterando sobre os elementos</strong>
for (String nome : deque) {
    System.out.println(nome);
}
// Sa√≠da:
// Ana
// Jo√£o

<strong>Verificando se a deque est√° vazia</strong>
System.out.println(deque.isEmpty()); // false

<strong>Limpar a deque</strong>
deque.clear();
System.out.println(deque.isEmpty()); // true

<strong>Outros m√©todos</strong>

// Acessar o primeiro e √∫ltimo elementos sem remov√™-los
System.out.println(deque.peekFirst()); // Retorna o primeiro elemento, ou null
System.out.println(deque.peekLast());  // Retorna o √∫ltimo elemento, ou null

// Remover e retornar o primeiro ou √∫ltimo elemento
System.out.println(deque.pollFirst()); // Retorna e remove o primeiro elemento
System.out.println(deque.pollLast());  // Retorna e remove o √∫ltimo elemento

// Converter a deque para um array
Object[] array = deque.toArray();
String[] stringArray = deque.toArray(new String[0]);

</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.util">
      <div class="title">Queue com LinkedList</div>
      <pre>
<code>

<strong>Vantagens</strong>
- Permite elementos nulos
- Boa performance para inser√ß√µes e remo√ß√µes nas extremidades
- Ordem de inser√ß√£o preservada

<strong>Desvantagens</strong>  
- Mais lenta para acesso aleat√≥rio (get(index))
- n√£o √© segura para acesso concorrente

Queue<String> fila = new LinkedList<>();

<strong>Adicionando elementos na fila</strong>
fila.add("Ana");
fila.add("Carlos");
fila.offer("Beatriz"); // Alternativa ao add, retorna false se falhar

<strong>Removendo elementos da fila</strong>
System.out.println(fila.poll());  // Remove e retorna o primeiro (Ana)
System.out.println(fila.remove()); // Igual ao poll, mas lan√ßa exce√ß√£o se vazia

<strong>Visualizando o primeiro sem remover</strong>
System.out.println(fila.peek());   // Mostra "Carlos"
System.out.println(fila.element()); // Igual ao peek, mas lan√ßa exce√ß√£o se vazia

<strong>Verificando se a fila est√° vazia</strong>
System.out.println(fila.isEmpty()); // false

<strong>Tamanho da fila</strong>
System.out.println(fila.size()); // 2

<strong>Iterando sobre a fila</strong>
for (String pessoa : fila) {
    System.out.println(pessoa);
}

<strong>Limpando a fila</strong>
fila.clear();

<strong>Verificando se est√° vazia novamente</strong>
System.out.println(fila.isEmpty()); // true
</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.util">
      <div class="title">Queue com ArrayDeque</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Mais r√°pido que LinkedList e Stack para opera√ß√µes de inser√ß√£o e remo√ß√£o nas pontas
- Justamente por n√£o ser sincronizado, √© mais r√°pido em ambientes single-thread
- Funciona tanto como Queue (FIFO) quanto como Stack (LIFO)
- Melhor alternativa a Stack e LinkedList para filas

<strong>Desvantagens</strong>
- N√£o permite null
- N√£o √© thread-safe
- Embora transparente, redimensionar o buffer interno pode ter custo de performance.

Queue<String> fila = new ArrayDeque<>();

<strong>Adicionando elementos na fila</strong>
fila.add("Ana");
fila.offer("Carlos");
fila.offer("Joana");

<strong>Removendo elementos da fila</strong>
System.out.println(fila.poll());   // Remove "Ana"
System.out.println(fila.remove()); // Remove "Carlos"

<strong>Visualizando o primeiro sem remover</strong>
System.out.println(fila.peek());    // "Joana"
System.out.println(fila.element()); // Tamb√©m "Joana"

<strong>Verificar se a fila est√° vazia</strong>
System.out.println(fila.isEmpty()); // false

<strong>Tamanho da fila</strong>
System.out.println(fila.size()); // 1

<strong>Iterando sobre a fila</strong>
for (String nome : fila) {
    System.out.println(nome);
}

<strong>Limpando a fila</strong>
fila.clear();

<strong>Verificando se est√° vazia novamente</strong>
System.out.println(fila.isEmpty()); // true
</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.util">
      <div class="title">PriorityQueue</div>
      <pre>
<code>

<strong>Vantagens</strong>
- Ordena√ß√£o autom√°tica por prioridade
- Permite elementos duplicados

<strong>Desvantagens</strong>  
- n√£o √© segura para uso por m√∫ltiplas threads simultaneamente
- Ordem de itera√ß√£o n√£o √© garantida
- N√£o permite null
- Remo√ß√£o de elementos arbitr√°rios √© lenta (remove(Object))

<strong>Criando uma fila de prioridade (ordem natural)</strong>
PriorityQueue<Integer> fila = new PriorityQueue<>();

fila.add(50);
fila.add(10);
fila.add(30);

<strong>Iterando (ordem n√£o garantida aqui)</strong>
for (int num : fila) {
    System.out.println(num);
}

<strong>Removendo em ordem de prioridade</strong>
System.out.println(fila.poll()); // 10
System.out.println(fila.poll()); // 30
System.out.println(fila.poll()); // 50

<strong>Verificando a cabe√ßa da fila</strong>
fila.offer(20);
System.out.println(fila.peek()); // 20

<strong>Fila com Comparator (ordem reversa)</strong>
PriorityQueue<String> nomes = new PriorityQueue<>(Collections.reverseOrder());

nomes.offer("Carlos");
nomes.offer("Ana");
nomes.offer("Bruno");

System.out.println(nomes.poll()); // "Carlos"
System.out.println(nomes.poll()); // "Bruno"
System.out.println(nomes.poll()); // "Ana"

<strong>Outros m√©todos √∫teis</strong>
System.out.println(nomes.isEmpty());
System.out.println(nomes.size());
nomes.clear();
</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.util.concurrent">
      <div class="title">ConcurrentLinkedQueue</div>
      <pre>
<code>
<strong>Vantagens</strong>
- √© thread-safe, o que significa que v√°rias threads podem acessar 
e modificar a fila ao mesmo tempo sem causar inconsist√™ncias. 
Isso √© garantido atrav√©s de t√©cnicas de sincroniza√ß√£o internas, 
como opera√ß√µes at√¥micas (sem necessidade de bloqueios expl√≠citos).

<strong>Desvantagens</strong>
- N√£o permite null
- Se voc√™ precisar de funcionalidades como espera ativa at√© que 
a fila tenha elementos dispon√≠veis ou at√© que haja espa√ßo para 
adicionar novos elementos (como em ArrayBlockingQueue), 
a ConcurrentLinkedQueue n√£o oferece esse tipo de opera√ß√£o

<strong>Criando a fila concorrente</strong>
ConcurrentLinkedQueue<String> fila = new ConcurrentLinkedQueue<>();

<strong>Adicionando elementos</strong>
fila.add("Tarefa1");
fila.offer("Tarefa2");

<strong>Removendo elementos</strong>
System.out.println(fila.poll()); // Tarefa1
System.out.println(fila.poll()); // Tarefa2

<strong>Visualizando o primeiro elemento (sem remover)</strong>
fila.offer("Tarefa3");
System.out.println(fila.peek()); // Tarefa3

<strong>Iterando sobre os elementos</strong>
fila.offer("Tarefa4");
fila.offer("Tarefa5");
for (String tarefa : fila) {
    System.out.println(tarefa);
}

<strong>Verificando se est√° vazia</strong>
System.out.println(fila.isEmpty());

<strong>Obtendo o tamanho atual</strong>
System.out.println(fila.size());

<strong>Remover elemento espec√≠fico (como uma lista)</strong>
fila.remove("Tarefa4");
</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.util">
      <div class="title">HashSet</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Desempenho r√°pido em opera√ß√µes b√°sicas (add, remove, contains)
- N√£o permite elementos duplicados
- Em compara√ß√£o com outras implementa√ß√µes de Set, como TreeSet, 
o HashSet costuma ser mais eficiente em termos de uso de mem√≥ria.

<strong>Desvantagens</strong>
- N√£o garante ordem de itera√ß√£o.
- Como o HashSet usa tabelas de dispers√£o (hash tables) para armazenar 
os elementos, ele pode consumir mais mem√≥ria do que outras implementa√ß√µes
de Set, como TreeSet, especialmente quando o n√∫mero de elementos 
for muito grande.
- N√£o √© thread-safe
- Para elementos personalizados (objetos de classes que voc√™ cria), 
o HashSet depende de uma implementa√ß√£o correta dos m√©todos hashCode() 
e equals() para garantir a unicidade dos elementos

<strong>Criando o HashSet</strong>
Set<String> frutas = new HashSet<>();

<strong>Adicionando elementos</strong>
frutas.add("Ma√ß√£");
frutas.add("Banana");
frutas.add("Laranja");
frutas.add("Ma√ß√£"); // Ignorado (duplicado)

<strong>Exibindo elementos</strong>
for (String fruta : frutas) {
    System.out.println(fruta);
}

<strong>Verificar se cont√©m um elemento</strong>
System.out.println(frutas.contains("Banana")); // true

<strong>Remover elemento</strong>
frutas.remove("Laranja");

<strong>Tamanho do conjunto</strong>
System.out.println(frutas.size());

<strong>Verificar se est√° vazio</strong>
System.out.println(frutas.isEmpty());

<strong>Limpar o conjunto</strong>
frutas.clear();
</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.util">
      <div class="title">LinkedHashSet</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Mant√©m a ordem em que os elementos foram adicionados.

<strong>Desvantagens</strong>  
- Um pouco mais lento que HashSet em termos de performance.

<strong>Criando o LinkedHashSet</strong>
Set<String> frutas = new LinkedHashSet<>();

<strong>Adicionando elementos</strong>
frutas.add("Ma√ß√£");
frutas.add("Banana");
frutas.add("Laranja");
frutas.add("Ma√ß√£"); // Ignorado (duplicado)

<strong>Exibindo elementos (ordem preservada)</strong>
for (String fruta : frutas) {
    System.out.println(fruta);
}
// Sa√≠da: Ma√ß√£, Banana, Laranja

<strong>Verificar se cont√©m um elemento</strong>
System.out.println(frutas.contains("Banana")); // true

<strong>Remover elemento</strong>
frutas.remove("Ma√ß√£");

<strong>Tamanho do conjunto</strong>
System.out.println(frutas.size());

<strong>Verificar se est√° vazio</strong>
System.out.println(frutas.isEmpty());

<strong>Limpar o conjunto</strong>
frutas.clear();
</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.util">
      <div class="title">TreeSet</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Ordena automaticamente
- Ideal para dados que precisam estar sempre em ordem

<strong>Desvantagens</strong>
- Mais lento que HashSet e LinkedHashSet
- N√£o permite null

<strong>Criando o TreeSet</strong>
Set<String> frutas = new TreeSet<>();

<strong>Adicionando elementos</strong>
frutas.add("Banana");
frutas.add("Ma√ß√£");
frutas.add("Laranja");
frutas.add("Banana"); // Ignorado (duplicado)

<strong>Exibindo elementos (ordem natural)</strong>
for (String fruta : frutas) {
    System.out.println(fruta);
}
// Sa√≠da ordenada: Banana, Laranja, Ma√ß√£

<strong>Verificar se cont√©m um elemento</strong>
System.out.println(frutas.contains("Ma√ß√£")); // true

<strong>Remover elemento</strong>
frutas.remove("Banana");

<strong>Tamanho do conjunto</strong>
System.out.println(frutas.size());

<strong>Verificar se est√° vazio</strong>
System.out.println(frutas.isEmpty());

<strong>Limpar o conjunto</strong>
frutas.clear();

<strong>Ordena√ß√£o personalizada (opcional)</strong>
TreeSet<String> frutasOrdenadas = new TreeSet<>(
    Comparator.reverseOrder()
);
frutasOrdenadas.addAll(List.of("Banana", "Ma√ß√£", "Laranja"));
System.out.println(frutasOrdenadas); // [Ma√ß√£, Laranja, Banana]
</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.util">
      <div class="title">EnumSet</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Leve e r√°pido
- Ideal para enums
- Ocupa pouca mem√≥ria

<strong>Desvantagens</strong>
- S√≥ funciona com enums
- Ordem segue a ordem de declara√ß√£o do enum
  
<strong>Declarando um enum</strong>
enum DiaSemana {
    SEGUNDA, TERCA, QUARTA, QUINTA, SEXTA, SABADO, DOMINGO
}

<strong>Criando um EnumSet com todos os dias</strong>
EnumSet<DiaSemana> todosDias = EnumSet.allOf(DiaSemana.class);

<strong>Criando um EnumSet com dias √∫teis</strong>
EnumSet<DiaSemana> diasUteis = EnumSet.range(DiaSemana.SEGUNDA, DiaSemana.SEXTA);

<strong>Criando um EnumSet espec√≠fico</strong>
EnumSet<DiaSemana> fimDeSemana = EnumSet.of(DiaSemana.SABADO, DiaSemana.DOMINGO);

<strong>Adicionando um elemento</strong>
diasUteis.add(DiaSemana.SABADO);

<strong>Removendo um elemento</strong>
diasUteis.remove(DiaSemana.QUARTA);

<strong>Verificando se cont√©m</strong>
System.out.println(diasUteis.contains(DiaSemana.SEGUNDA)); // true

<strong>Iterando</strong>
for (DiaSemana dia : fimDeSemana) {
    System.out.println(dia);
}

<strong>Limpando</strong>
fimDeSemana.clear();
</code>
      </pre>
    </div>
    
    
    <div class="block" data-tags="java.util">
      <div class="title">HashMap</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Muito r√°pido para busca, inser√ß√£o e remo√ß√£o
- Ideal quando a ordem n√£o importa

<strong>Desvantagens</strong>
- Ordem imprevis√≠vel
- N√£o √© thread-safe

<strong>Criando um HashMap</strong>
HashMap&lt;String, Integer&gt; idades = new HashMap<>();

<strong>Adicionando elementos</strong>
idades.put("Ana", 25);
idades.put("Carlos", 30);
idades.put("Bruna", 28);

<strong>Acessando valor pela chave</strong>
System.out.println(idades.get("Ana")); // 25

<strong>Verificando se a chave existe</strong>
System.out.println(idades.containsKey("Carlos")); // true

<strong>Verificando se o valor existe</strong>
System.out.println(idades.containsValue(28)); // true

<strong>Removendo um elemento</strong>
idades.remove("Carlos");

<strong>Iterando com for-each</strong>
for (Map.Entry&lt;String, Integer&gt; entrada : idades.entrySet()) {
    System.out.println(entrada.getKey() + " -> " + entrada.getValue());
}

<strong>Iterando apenas pelas chaves</strong>
for (String nome : idades.keySet()) {
    System.out.println(nome);
}

<strong>Iterando apenas pelos valores</strong>
for (Integer idade : idades.values()) {
    System.out.println(idade);
}

<strong>Tamanho do mapa</strong>
System.out.println(idades.size());

<strong>Substituindo o valor de uma chave existente</strong>
idades.put("Ana", 26);

<strong>Limpar tudo</strong>
idades.clear();

<strong>Verificar se est√° vazio</strong>
System.out.println(idades.isEmpty()); // true
</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.util">
      <div class="title">LinkedHashMap</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Mant√©m a ordem de inser√ß√£o
- Boa previsibilidade para itera√ß√£o

<strong>Desvantagens</strong>
- Ligeiramente mais lento que HashMap

<strong>Criando um LinkedHashMap</strong>
LinkedHashMap&lt;String, Integer&gt; notas = new LinkedHashMap<>();

<strong>Adicionando elementos</strong>
notas.put("Maria", 9);
notas.put("Jo√£o", 7);
notas.put("Pedro", 8);

<strong>Preserva ordem de inser√ß√£o:</strong>
for (Map.Entry&lt;String, Integer&gt; entry : notas.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}

<strong>Acessando valor pela chave</strong>
System.out.println(notas.get("Maria")); // 9

<strong>Substituindo valor</strong>
notas.put("Maria", 10); // atualiza a nota

<strong>Verificando exist√™ncia</strong>
notas.containsKey("Jo√£o"); // true
notas.containsValue(8);    // true

<strong>Removendo um item</strong>
notas.remove("Jo√£o");

<strong>Iterando somente as chaves</strong>
for (String nome : notas.keySet()) {
    System.out.println(nome);
}

<strong>Iterando somente os valores</strong>
for (Integer nota : notas.values()) {
    System.out.println(nota);
}

<strong>Tamanho e limpeza</strong>
System.out.println(notas.size());
notas.clear();
System.out.println(notas.isEmpty());
</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.util">
      <div class="title">TreeMap</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Mant√©m as chaves ordenadas naturalmente (ou por um Comparator)
- √ötil para intervalos, buscas de menor/maior, etc.

<strong>Desvantagens</strong>
- Mais lento que HashMap e LinkedHashMap
- Custo de ordena√ß√£o (baseado em √°rvore vermelha-preta)

<strong>Criando um TreeMap</strong>
TreeMap&lt;String, Integer&gt; estoque = new TreeMap<>();

<strong>Adicionando elementos</strong>
estoque.put("Ma√ß√£", 30);
estoque.put("Banana", 20);
estoque.put("Laranja", 25);

<strong>Ordem natural (ordenado pela chave):</strong>
for (Map.Entry&lt;String, Integer&gt; entry : estoque.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}

<strong>Acessando um valor</strong>
System.out.println(estoque.get("Banana")); // 20

<strong>Substituindo valor</strong>
estoque.put("Banana", 22); // atualiza

<strong>Verificando exist√™ncia</strong>
estoque.containsKey("Ma√ß√£");    // true
estoque.containsValue(25);      // true

<strong>Removendo item</strong>
estoque.remove("Laranja");

<strong>Iterando pelas chaves</strong>
for (String fruta : estoque.keySet()) {
    System.out.println(fruta);
}

<strong>Iterando pelos valores</strong>
for (Integer quantidade : estoque.values()) {
    System.out.println(quantidade);
}

<strong>Primeiro e √∫ltimo elementos</strong>
System.out.println(estoque.firstKey()); // Banana
System.out.println(estoque.lastKey());  // Ma√ß√£

<strong>Tamanho e limpeza</strong>
System.out.println(estoque.size());
estoque.clear();
System.out.println(estoque.isEmpty());
</code>
      </pre>
    </div>

    <div class="block" data-tags="java.util">
      <div class="title">EnumMap</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Extremamente eficiente para chaves do tipo Enum, 
utilizando um array interno para armazenamento.
- Mais r√°pido e eficiente em termos de mem√≥ria quando 
comparado a outras implementa√ß√µes de Map.

<strong>Desvantagens</strong>
Somente pode ser usado com Enum como chave.
N√£o funciona bem quando as chaves n√£o s√£o enumeradas.

<strong>Criando um EnumMap</strong>
enum Fruta { MA√áA, BANANA, LARANJA }
EnumMap&lt;Fruta, Integer&gt; estoque = new EnumMap&lt;&gt;(Fruta.class);

<strong>Adicionando elementos</strong>
estoque.put(Fruta.MA√áA, 30);
estoque.put(Fruta.BANANA, 20);
estoque.put(Fruta.LARANJA, 25);

<strong>Iterando atrav√©s do EnumMap</strong>
for (Map.Entry&lt;Fruta, Integer&gt; entry : estoque.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}

<strong>Acessando um valor</strong>
System.out.println(estoque.get(Fruta.BANANA)); // 20

<strong>Verificando exist√™ncia</strong>
System.out.println(estoque.containsKey(Fruta.MA√áA));    // true
System.out.println(estoque.containsValue(25));          // true

<strong>Removendo item</strong>
estoque.remove(Fruta.LARANJA);

<strong>Tamanho e limpeza</strong>
System.out.println(estoque.size()); // 2
estoque.clear();
System.out.println(estoque.isEmpty()); // true
</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.util">
      <div class="title">ConcurrentHashMap</div>
      <pre>
<code>
<strong>Vantagens</strong>
- ConcurrentHashMap √© thread-safe sem a necessidade 
de bloquear toda a estrutura.
- Excelente para ambientes concorrentes onde 
m√∫ltiplos threads acessam o mapa simultaneamente.
- Opera√ß√µes de leitura s√£o altamente eficientes.

<strong>Desvantagens</strong>
- Mais lento que outras implementa√ß√µes de Map 
em ambientes de √∫nico thread, devido ao 
gerenciamento de concorr√™ncia.
A API oferece algumas complexidades adicionais 
(exemplo: opera√ß√£o computeIfAbsent).

<strong>Criando um ConcurrentHashMap</strong>
ConcurrentHashMap&lt;String, Integer&gt; mapaConcorrente = new ConcurrentHashMap&lt;&gt;();

<strong>Adicionando elementos</strong>
mapaConcorrente.put("Ma√ß√£", 10);
mapaConcorrente.put("Banana", 15);
mapaConcorrente.put("Laranja", 20);

<strong>Iterando atrav√©s do ConcurrentHashMap</strong>
for (Map.Entry&lt;String, Integer&gt; entry : mapaConcorrente.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}

<strong>Acessando um valor</strong>
System.out.println(mapaConcorrente.get("Banana")); // 15

<strong>Verificando exist√™ncia</strong>
System.out.println(mapaConcorrente.containsKey("Ma√ß√£"));  // true
System.out.println(mapaConcorrente.containsValue(25));    // false

<strong>Removendo item</strong>
mapaConcorrente.remove("Laranja");

<strong>Usando putIfAbsent</strong>
mapaConcorrente.putIfAbsent("Ma√ß√£", 25);  // N√£o altera, pois "Ma√ß√£" j√° existe

<strong>Tamanho e limpeza</strong>
System.out.println(mapaConcorrente.size());  // 2
mapaConcorrente.clear();
System.out.println(mapaConcorrente.isEmpty()); // true
</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.util">
      <div class="title">Collections.synchronizedList</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Garante que a lista seja thread-safe, 
ou seja, segura para acesso em m√∫ltiplas threads simult√¢neas, 
com a sincroniza√ß√£o embutida.
- √ötil quando se trabalha em ambientes concorrentes, onde v√°rias 
threads podem acessar ou modificar a lista.

<strong>Desvantagens</strong>  
- A sincroniza√ß√£o pode resultar em algum overhead de performance, 
especialmente em opera√ß√µes de leitura, dependendo do n√∫mero de 
threads simult√¢neas acessando a lista.

- Requer que todas as opera√ß√µes de leitura e itera√ß√£o sejam feitas 
dentro de um bloco synchronized, o que pode ser um pouco mais 
complexo de gerenciar.

<strong>Criando uma lista sincronizada</strong>
List&lt;String&gt; lista = new ArrayList&lt;&gt;();
List&lt;String&gt; listaSincronizada = Collections.synchronizedList(lista);

<strong>Adicionando elementos</strong>
listaSincronizada.add("Ma√ß√£");
listaSincronizada.add("Banana");
listaSincronizada.add("Laranja");

<strong>Iterando atrav√©s da lista sincronizada</strong>
// Para itera√ß√£o, √© necess√°rio sincronizar explicitamente o bloco de c√≥digo
synchronized (listaSincronizada) {
    for (String item : listaSincronizada) {
        System.out.println(item);
    }
}

<strong>Verificando se cont√©m um elemento</strong>
System.out.println(listaSincronizada.contains("Banana"));  // true

<strong>Removendo um item</strong>
listaSincronizada.remove("Laranja");

<strong>Verificando o tamanho</strong>
System.out.println(listaSincronizada.size());  // 2

<strong>Limpar a lista</strong>
listaSincronizada.clear();
System.out.println(listaSincronizada.isEmpty());  // true
</code>
      </pre>
    </div>
    
    <div class="block" data-tags="java.util">
      <div class="title">Collections.unmodifiableList</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Garante que a lista n√£o seja modificada ap√≥s ser criada, 
o que √© ideal para situa√ß√µes em que voc√™ deseja garantir 
que os dados n√£o sejam alterados acidentalmente ou 
durante o uso em APIs p√∫blicas.
- Aumenta a seguran√ßa e integridade dos dados.

<strong>Desvantagens</strong>
- N√£o permite modifica√ß√µes, o que pode ser uma limita√ß√£o 
quando for necess√°rio realizar altera√ß√µes na lista depois
de sua cria√ß√£o.
- Qualquer tentativa de modifica√ß√£o resultar√° em 
uma UnsupportedOperationException
  
<strong>Criando uma lista imut√°vel</strong>
List&lt;String&gt; lista = new ArrayList&lt;&gt;();
lista.add("Ma√ß√£");
lista.add("Banana");
lista.add("Laranja");

// Tornando a lista imut√°vel
List&lt;String&gt; listaImutavel = Collections.unmodifiableList(lista);

<strong>Tentando modificar a lista imut√°vel</strong>
try {
    listaImutavel.add("Uva");  // Lan√ßar√° uma exce√ß√£o UnsupportedOperationException
} catch (UnsupportedOperationException e) {
    System.out.println("N√£o √© poss√≠vel modificar uma lista imut√°vel.");
}

<strong>Acessando um item da lista imut√°vel</strong>
System.out.println(listaImutavel.get(0));  // Ma√ß√£

<strong>Verificando o tamanho da lista</strong>
System.out.println(listaImutavel.size());  // 3

<strong>Verificando se cont√©m um item</strong>
System.out.println(listaImutavel.contains("Banana"));  // true
</code>
      </pre>
    </div>

    <h2 class="section-title">üìò Thread</h2>

    <div class="block" data-tags="java.lang">
      <div class="title">Thread (java.lang.Thread)</div>
      <pre>
<code>
<strong>Vantagens</strong>
- Permite que seu programa execute tarefas simultaneamente.
- Pode melhorar o desempenho em sistemas com m√∫ltiplos n√∫cleos.
- Ideal para opera√ß√µes demoradas, como chamadas de rede ou leitura de arquivos, sem bloquear a interface principal.

<strong>Desvantagens</strong>
- Introduz complexidade no c√≥digo.
- Pode causar erros dif√≠ceis de detectar como race conditions, deadlocks e concorr√™ncia incorreta.
- Requer cuidado com o uso de recursos compartilhados.

<strong>Criando uma Thread estendendo a classe Thread</strong>
class MinhaThread extends Thread {
    public void run() {
        System.out.println("Executando na thread: " + Thread.currentThread().getName());
    }
}

MinhaThread t1 = new MinhaThread();
t1.start();  // Inicia a thread

<strong>Criando uma Thread implementando Runnable</strong>
class MinhaTarefa implements Runnable {
    public void run() {
        System.out.println("Executando tarefa em: " + Thread.currentThread().getName());
    }
}

Thread t2 = new Thread(new MinhaTarefa());
t2.start();  // Inicia a thread

<strong>Usando express√£o lambda com Runnable (Java 8+)</strong>
Thread t3 = new Thread(() -> {
    System.out.println("Executando com lambda em: " + Thread.currentThread().getName());
});
t3.start();

<strong>Esperando uma Thread terminar (join)</strong>
try {
    t1.join();  // Espera a thread t1 terminar
    t2.join();
    t3.join();
} catch (InterruptedException e) {
    e.printStackTrace();
}

<strong>Verificando se uma Thread est√° viva</strong>
System.out.println(t1.isAlive());  // true ou false
</code>
        </pre>
      </div>
      
      <div class="block" data-tags="java.util.concurrent">
        <div class="title">ExecutorService</div>
        <pre>
<code>
<strong>Vantagens</strong>
- Gerencia um pool de threads, evitando a cria√ß√£o e destrui√ß√£o frequente de threads.
- Ideal para aplica√ß√µes que precisam executar m√∫ltiplas tarefas de forma eficiente.
- Fornece m√©todos para controle mais refinado da execu√ß√£o de tarefas.

<strong>Desvantagens</strong>
- Precisa ser finalizado corretamente com shutdown().
- Pode ser complexo para tarefas que dependem entre si.

<strong>Criando um ExecutorService com um pool fixo</strong>
ExecutorService executor = Executors.newFixedThreadPool(3);

<strong>Executando uma tarefa</strong>
executor.execute(() -> {
    System.out.println("Executando em thread do pool: " + Thread.currentThread().getName());
});

<strong>Executando tarefa com retorno (Callable)</strong>
Callable&lt;String&gt; tarefa = () -> {
    return "Resultado da tarefa";
};

Future&lt;String&gt; futuro = executor.submit(tarefa);
try {
    System.out.println(futuro.get());  // Espera e obt√©m o resultado
} catch (Exception e) {
    e.printStackTrace();
}

<strong>Encerrando o ExecutorService</strong>
executor.shutdown();
</code>
        </pre>
      </div>
      
      <div class="block" data-tags="java.lang">
        <div class="title">synchronized</div>
        <pre>
<code>
<strong>Vantagens</strong>
- Garante que apenas uma thread execute um bloco de c√≥digo por vez.
- Evita problemas como race conditions ao acessar recursos compartilhados.

<strong>Desvantagens</strong>
- Pode causar gargalos se mal utilizado.
- Pode levar a deadlocks se houver m√° coordena√ß√£o entre os recursos.

<strong>M√©todo sincronizado</strong>
public synchronized void incrementar() {
    contador++;
}

<strong>Bloco sincronizado</strong>
public void incrementar() {
    synchronized(this) {
        contador++;
    }
}

<strong>Sincronizando em um objeto espec√≠fico</strong>
Object lock = new Object();

public void tarefa() {
    synchronized(lock) {
        // Somente uma thread pode acessar aqui por vez
        System.out.println("Acessando recurso com lock");
    }
}

<strong>Evite isso!</strong>
// Sincronizar em objetos mut√°veis, como Strings ou listas, pode ser perigoso
</code>
        </pre>
      </div>
      
      <div class="block" data-tags="java-concorrencia">
        <div class="title">wait(), notify(), notifyAll()</div>
        <pre>
<code>
<strong>O que s√£o?</strong>
- S√£o m√©todos da classe Object usados para comunica√ß√£o entre threads.
- Devem ser usados dentro de blocos sincronizados (com synchronized).

<strong>wait()</strong>
- Faz a thread atual "esperar" at√© que outra thread chame notify() ou notifyAll().
- Libera o monitor do objeto (o lock), permitindo que outras threads entrem no bloco synchronized.

<strong>notify()</strong>
- Acorda uma thread que est√° esperando (`wait()`) no mesmo objeto monitor.

<strong>notifyAll()</strong>
- Acorda todas as threads que est√£o esperando (`wait()`) no objeto monitor.

<strong>Regras importantes</strong>
- S√≥ funcionam dentro de blocos sincronizados (sen√£o lan√ßam IllegalMonitorStateException).
- Sempre use um objeto comum para `wait()` e `notify()` (ex: `synchronized (this)`).

<strong>Exemplo: Produtor e Consumidor</strong>
class Buffer {
    private int valor;
    private boolean disponivel = false;

    public synchronized void produzir(int novoValor) {
        while (disponivel) {
            try {
                wait();  // Espera at√© que o valor seja consumido
            } catch (InterruptedException e) {}
        }
        valor = novoValor;
        disponivel = true;
        System.out.println("Produzido: " + valor);
        notify();  // Avisa que h√° um novo valor dispon√≠vel
    }

    public synchronized int consumir() {
        while (!disponivel) {
            try {
                wait();  // Espera at√© que um valor seja produzido
            } catch (InterruptedException e) {}
        }
        disponivel = false;
        System.out.println("Consumido: " + valor);
        notify();  // Avisa que o buffer est√° livre para produ√ß√£o
        return valor;
    }
}

<strong>Uso das threads</strong>
Buffer buffer = new Buffer();

Thread produtor = new Thread(() -> {
    for (int i = 0; i < 5; i++) {
        buffer.produzir(i);
    }
});

Thread consumidor = new Thread(() -> {
    for (int i = 0; i < 5; i++) {
        buffer.consumir();
    }
});

produtor.start();
consumidor.start();
</code>
        </pre>
      </div>
      
      <div class="block" data-tags="java-concorrencia">
        <div class="title">wait()/notify() vs BlockingQueue</div>
        <pre>
<code>
<strong>wait()/notify()</strong>
‚úÖ Mais controle e flexibilidade.
‚ö†Ô∏è Mais c√≥digo, f√°cil de errar (risco de deadlock e race conditions).
üîß Ideal quando voc√™ precisa de uma l√≥gica de sincroniza√ß√£o customizada.

<strong>BlockingQueue (java.util.concurrent)</strong>
‚úÖ Simples de usar e segura para m√∫ltiplas threads.
‚úÖ J√° trata sincroniza√ß√£o internamente.
‚úÖ Evita uso manual de synchronized, wait() e notify().
üîß Ideal para cen√°rios Produtor-Consumidor.

<strong>Exemplo com BlockingQueue</strong>
import java.util.concurrent.*;

BlockingQueue&lt;Integer&gt; fila = new ArrayBlockingQueue&lt;&gt;(10);

Thread produtor = new Thread(() -> {
    try {
        for (int i = 0; i < 5; i++) {
            fila.put(i);  // Espera se a fila estiver cheia
            System.out.println("Produzido: " + i);
        }
    } catch (InterruptedException e) {}
});

Thread consumidor = new Thread(() -> {
    try {
        for (int i = 0; i < 5; i++) {
            int valor = fila.take();  // Espera se a fila estiver vazia
            System.out.println("Consumido: " + valor);
        }
    } catch (InterruptedException e) {}
});

produtor.start();
consumidor.start();

<strong>Quando usar cada um?</strong>
üß† Use wait()/notify() quando:
- Precisa de l√≥gica mais complexa ou sincroniza√ß√£o em diferentes objetos.
- Est√° aprendendo o funcionamento de baixo n√≠vel de threads.

üöÄ Use BlockingQueue quando:
- Quer simplicidade, seguran√ßa e performance.
- Est√° implementando produtores/consumidores com foco em robustez.
</code>
        </pre>
      </div>
      
      <div class="block" data-tags="java-concorrencia">
        <div class="title">Semaphore</div>
        <pre>
<code>
<strong>O que √©?</strong>
- Controla o n√∫mero de threads que podem acessar um recurso ao mesmo tempo.
- √ötil para limitar o acesso a uma quantidade finita de recursos (como conex√µes de banco, impressoras, etc).

<strong>Exemplo</strong>
import java.util.concurrent.Semaphore;

Semaphore semaforo = new Semaphore(2);  // Limite de 2 threads simult√¢neas

Runnable tarefa = () -> {
    try {
        semaforo.acquire();  // Pede permiss√£o
        System.out.println(Thread.currentThread().getName() + " entrou");
        Thread.sleep(1000);
        System.out.println(Thread.currentThread().getName() + " saiu");
    } catch (InterruptedException e) {
    } finally {
        semaforo.release();  // Libera permiss√£o
    }
};

for (int i = 0; i < 5; i++) {
    new Thread(tarefa).start();
}

<strong>Resultado:</strong>
No m√°ximo 2 threads executam o bloco "cr√≠tico" ao mesmo tempo.
</code>
        </pre>
      </div>
      
      <div class="block" data-tags="java-concorrencia">
        <div class="title">CountDownLatch</div>
        <pre>
<code>
<strong>O que √©?</strong>
- Permite que uma ou mais threads esperem at√© que outras completem alguma opera√ß√£o.

<strong>Exemplo: Esperar 3 tarefas finalizarem</strong>
import java.util.concurrent.CountDownLatch;

CountDownLatch latch = new CountDownLatch(3);

Runnable tarefa = () -> {
    System.out.println(Thread.currentThread().getName() + " trabalhando...");
    try { Thread.sleep(1000); } catch (InterruptedException e) {}
    latch.countDown();  // Reduz o contador
};

new Thread(tarefa).start();
new Thread(tarefa).start();
new Thread(tarefa).start();

try {
    latch.await();  // Espera o contador chegar a 0
    System.out.println("Todas as tarefas conclu√≠das!");
} catch (InterruptedException e) {}

<strong>Ideal para</strong>
- Esperar m√∫ltiplas tarefas antes de seguir.
</code>
        </pre>
      </div>

      <div class="block" data-tags="java-concorrencia">
        <div class="title">CyclicBarrier</div>
        <pre>
<code>
<strong>O que √©?</strong>
- Permite que um grupo de threads esperem umas pelas outras at√© atingirem um "ponto de barreira".
- Pode ser reutilizado (diferente do CountDownLatch).

<strong>Exemplo: 3 threads esperam juntas</strong>
import java.util.concurrent.CyclicBarrier;

CyclicBarrier barreira = new CyclicBarrier(3, () -> {
    System.out.println("Todas chegaram √† barreira! Executando a√ß√£o final.");
});

Runnable tarefa = () -> {
    try {
        System.out.println(Thread.currentThread().getName() + " pronto");
        barreira.await();  // Espera as outras
        System.out.println(Thread.currentThread().getName() + " passou a barreira");
    } catch (Exception e) {}
};

for (int i = 0; i < 3; i++) {
    new Thread(tarefa).start();
}

<strong>Ideal para</strong>
- Sincronizar fases de execu√ß√£o entre threads.
</code>
        </pre>
      </div>
      
      <div class="block" data-tags="java-concorrencia">
        <div class="title">CompletableFuture</div>
        <pre>
<code>
<strong>O que √©?</strong>
- Representa uma computa√ß√£o ass√≠ncrona.
- Permite encadear tarefas de forma n√£o bloqueante.

<strong>Exemplo simples</strong>
import java.util.concurrent.*;

CompletableFuture&lt;String&gt; futuro = CompletableFuture.supplyAsync(() -> {
    return "Resultado";
});

futuro.thenAccept(resultado -> {
    System.out.println("Recebido: " + resultado);
});

<strong>Encadeando tarefas</strong>
CompletableFuture&lt;String&gt; encadeado = futuro
    .thenApply(resultado -> resultado + " modificado")
    .thenApply(String::toUpperCase);

System.out.println(encadeado.get());  // Resultado MODIFICADO

<strong>Ideal para</strong>
- Executar tarefas ass√≠ncronas de forma fluente e eficiente.
</code>
        </pre>
      </div>
      
      <div class="block" data-tags="java-concorrencia">
        <div class="title">ForkJoinPool</div>
        <pre>
<code>
<strong>O que √©?</strong>
- Um pool de threads especializado em dividir tarefas recursivas em subtarefas menores.
- Ideal para paralelizar tarefas intensivas (divide and conquer).

<strong>Exemplo b√°sico</strong>
import java.util.concurrent.*;

class SomaTask extends RecursiveTask&lt;Integer&gt; {
    int inicio, fim;

    SomaTask(int inicio, int fim) {
        this.inicio = inicio;
        this.fim = fim;
    }

    protected Integer compute() {
        if (fim - inicio &lt;= 10) {
            int soma = 0;
            for (int i = inicio; i &lt;= fim; i++) soma += i;
            return soma;
        } else {
            int meio = (inicio + fim) / 2;
            SomaTask t1 = new SomaTask(inicio, meio);
            SomaTask t2 = new SomaTask(meio + 1, fim);
            t1.fork();
            return t2.compute() + t1.join();
        }
    }
}

ForkJoinPool pool = new ForkJoinPool();
int resultado = pool.invoke(new SomaTask(1, 100));
System.out.println("Soma: " + resultado);

<strong>Ideal para</strong>
- Tarefas grandes que podem ser divididas em partes menores.
</code>
        </pre>
      </div>
      
      <div class="block" data-tags="java-concorrencia">
        <div class="title">ForkJoinPool</div>
        <pre>
<code>
<strong>Paralelismo vs Concorr√™ncia</strong>

<strong>Paralelismo:</strong> Refere-se √† execu√ß√£o de m√∫ltiplas tarefas 
simultaneamente em diferentes n√∫cleos do processador.

<strong>Concorr√™ncia:</strong> Refere-se √† execu√ß√£o de m√∫ltiplas tarefas 
de forma alternada (intercalada), em um √∫nico n√∫cleo ou 
m√∫ltiplos n√∫cleos, com a ideia de que o processador 
troca rapidamente entre elas.

<strong>Exemplo de paralelismo:</strong>

Usando ForkJoinPool para dividir um problema em subtarefas 
e execut√°-las simultaneamente.

<strong>Exemplo de concorr√™ncia:</strong>

Usando ExecutorService para gerenciar tarefas que n√£o precisam 
ser executadas simultaneamente, mas podem ser divididas para 
otimizar o tempo total de execu√ß√£o.
</code>
        </pre>
      </div>

      <h2 class="section-title">üìò Strams</h2>
      
      <div class="block" data-tags="java-concorrencia">
        <div class="title">Streams</div>
        <pre>
<code>
<strong>Cria√ß√£o de Streams</strong>

List<String> lista = Arrays.asList(
  "ma√ß√£", "banana", "laranja");
Stream<String> stream = lista.stream();
    
int[] numeros = {1, 2, 3, 4, 5};
IntStream streamNumeros = Arrays
  .stream(numeros);

Stream<String> stream = Stream.of("a", "b", "c");

<strong>Streams - filter</strong>

List<String> lista = Arrays.asList(
  "ma√ß√£", "banana", "laranja");
List<String> listaFiltrada = lista.stream()
              .filter(s -> s.startsWith("b"))
              .collect(Collectors
              .toList());

System.out.println(listaFiltrada); // [banana]

<strong>Streams - map</strong>

List<String> lista = Arrays.asList(
  "ma√ß√£", "banana", "laranja");
List<String> listaMaiuscula = lista.stream()
                    .map(String::toUpperCase)
                    .collect(Collectors
                    .toList());
System.out.println(listaMaiuscula); 
// [MA√á√É, BANANA, LARANJA]
</code> 
        </pre>
      </div>

      <div class="block" data-tags="java-streams">
        <div class="title">Streams</div>
        <pre>
<code>
<strong>Streams - distinct</strong>

List<String> lista = Arrays.asList(
  "ma√ß√£", "banana", "laranja", "banana");
List<String> listaDistinta = lista.stream()
                      .distinct()
                      .collect(Collectors
                      .toList());
System.out.println(listaDistinta); 
// [ma√ß√£, banana, laranja]

<strong>Streams - sorted</strong>

List<String> lista = Arrays.asList(
  "ma√ß√£", "banana", "laranja");
List<String> listaOrdenada = lista.stream()
                      .sorted()
                      .collect(Collectors
                      .toList());
System.out.println(listaOrdenada); 
// [banana, laranja, ma√ß√£]

<strong>Streams - forEach</strong>

List<String> lista = Arrays.asList(
  "ma√ß√£", "banana", "laranja");
lista.stream()
  .forEach(System.out::println); 
  // Imprime cada item da lista
</code>
              </pre>      
            </div>

      <div class="block" data-tags="java-streams">
        <div class="title">Streams</div>
        <pre>
<code>
<strong>Streams - reduce</strong>  

//Realiza uma redu√ß√£o em um stream 
de elementos, combinando-os de 
acordo com um acumulador.

List<Integer> lista = Arrays
  .asList(1, 2, 3, 4);
int soma = lista.stream()
                .reduce(0, Integer::sum);
System.out.println(soma); // 10
  
<strong>Streams - count</strong>

List<String> lista = Arrays
  .asList("ma√ß√£", "banana", "laranja");
long count = lista.stream().count();
System.out.println(count); // 3

<strong>Streams - paralelo</strong>

List<Integer> lista = Arrays
  .asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
int somaParalela = lista
  .parallelStream()
  .reduce(0, Integer::sum);
System.out.println(somaParalela); // 55
</code>
          </pre>
        </div>

      <div class="block" data-tags="java-streams">
        <div class="title">Streams</div>
        <pre>
<code>
<strong>Streams - Map</strong>

List<String> nomes = Arrays
  .asList("ana", "jo√£o", "maria");

List<String> nomesMaiusculos = nomes.stream()
  // Transforma cada nome em MAI√öSCULO
  .map(String::toUpperCase)
  .collect(Collectors.toList());
  
System.out.println(nomesMaiusculos); 
// [ANA, JO√ÉO, MARIA]
  
<strong>Streams - FlatMap</strong>

List<List<String>> nomesAninhados = Arrays.asList(
  Arrays.asList("ana", "jo√£o"),
  Arrays.asList("maria", "pedro")
);

List<String> nomes = nomesAninhados.stream()
  // "Achata" os sub-streams em um s√≥
  .flatMap(List::stream) 
  .collect(Collectors.toList());

System.out.println(nomes); 
// [ana, jo√£o, maria, pedro]
</code>
        </pre>
      </div>
      
      <div class="block" data-tags="java-streams">
        <div class="title">Streams</div>
        <pre>
<code>
<strong>Streams - Limit</strong>

List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5, 6);

List<Integer> primeirosTres = numeros.stream()
    .limit(3) // Pega s√≥ os 3 primeiros
    .collect(Collectors.toList());

System.out.println(primeirosTres); // [1, 2, 3]
  
<strong>Streams - Skip</strong>

List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5, 6);

List<Integer> depoisDosDoisPrimeiros = numeros.stream()
    .skip(2) // Pula os dois primeiros
    .collect(Collectors.toList());

System.out.println(depoisDosDoisPrimeiros); 
// [3, 4, 5, 6]
</code>
        </pre>
      </div>

      <div class="block" data-tags="java-streams">
        <div class="title">Streams</div>
        <pre>
<code>
<strong>Streams - peek</strong>

List<String> nomes = Arrays
  .asList("ana", "jo√£o", "maria");

List<String> resultado = nomes.stream()
.peek(
  nome -> System.out.println(
    "Original: " + nome))
.map(String::toUpperCase)
.peek(nome -> System.out.println(
  "Mai√∫sculo: " + nome))
.collect(Collectors.toList());

System.out.println(resultado); 
// [ANA, JO√ÉO, MARIA]      
</code>
        </pre>
      </div>

      <h2 class="section-title">üìò Tipos de Classe</h2>

      <div class="block" data-tags="java-streams">
        <div class="title">Classes</div>
        <pre>
<code>
A forma geral da declara√ß√£o de uma classe 
√© a seguinte

[modificadores] class [nome classe] extends 
[nome super] implements [nome interface]

<strong>Modificadores</strong>

<strong>public: </strong>permite definir classes p√∫blicas. 
Estas classes s√£o acess√≠veis a partir de 
qualquer objeto, independentemente do package. 
Uma classe p√∫blica deve ser a √∫nica classe 
desse tipo no arquivo em que est√° declarada e 
o nome do arquivo deve ser igual ao da classe.

<strong>friendly:</strong> se nenhum modificador de classe for
especificado, ent√£o a classe ser√° considerada 
friendly. Apenas os objetos integrantes do 
mesmo package podem utilizar uma 
classe friendly.

<strong>final:</strong> Uma classe final pode ser instanciada, 
mas n√£o pode ser derivada, isto √©, n√£o pode 
ser superclasse de nenhuma subclasse. Algumas 
classes predefinidas no ambiente Java t√™m esta 
propriedade. Outras n√£o, como as classes no 
java.awt, por exemplo.

<strong>abstract:</strong> Classes abstratas s√£o aquelas que 
cont√©m ao menos um m√©todo incompleto. 
Desse modo uma classe abstrata n√£o pode 
ser instanciada, mas pode ser derivada. 
Neste caso, a subclasse deve prover o corpo 
do m√©todo para que possa ser instanciada. 
Isto √© muito √∫til quando desejamos 
definir em uma classe regras gerais para o 
comportamento de uma parte do programa, 
para que, mais tarde, as regras mais 
espec√≠ficas sejam introduzidas por subclasses.

<strong>sealed: </strong> Quando uma classe √© marcada como 
<code>sealed</code>, ela deve especificar quais subclasses 
podem herd√°-la usando a cl√°usula <code>permits</code>.
</code>
        </pre>
      </div>

      <div class="block" data-tags="java-classes">
        <div class="title">Classe p√∫blica</div>
        <pre>
<code>
<strong>public:</strong> O modificador <code>public</code> define 
uma classe que pode ser acessada a partir 
de qualquer outro pacote no projeto.

<strong>Regras importantes:</strong>
- Apenas uma classe <code>public</code> pode existir por 
arquivo .java.
- O nome do arquivo deve ser o mesmo da classe 
p√∫blica.
- A classe pode ser acessada diretamente por 
outras classes.

<strong>Exemplo:</strong>

// Arquivo: MinhaClasse.java
public class MinhaClasse {
    public void saudacao() {
        System.out.println("Ol√°! Eu sou uma 
        classe p√∫blica.");
    }
}

// Em outro arquivo no mesmo ou outro pacote:
public class Teste {
    public static void main(String[] args) {
        MinhaClasse obj = new MinhaClasse();
        obj.saudacao();
    }
}

<strong>Uso comum:</strong> Classes p√∫blicas s√£o usadas para 
expor funcionalidades principais, como APIs, 
servi√ßos, controladores ou classes principais 
com <code>main()</code>.
</code>
        </pre>
      </div>

      <div class="block" data-tags="java-classes">
        <div class="title">Classe friendly (default)</div>
        <pre>
<code>
<strong>friendly (ou default):</strong> Quando uma classe n√£o 
possui nenhum modificador de acesso expl√≠cito 
como <code>public</code>, <code>protected</code> ou <code>private</code>, ela √© 
considerada uma classe <strong>friendly</strong> ou de acesso 
<strong>package-private</strong>.

<strong>Comportamento:</strong>
- S√≥ pode ser acessada por outras classes 
dentro do mesmo pacote.
- N√£o pode ser acessada por classes de 
pacotes diferentes.

<strong>Exemplo:</strong>

// Arquivo: MinhaClasseAmiga.java
class MinhaClasseAmiga {
    void saudacao() {
        System.out.println(
          "Ol√°! Eu sou uma classe friendly.");
    }
}

// Outra classe no mesmo pacote
public class Teste {
    public static void main(String[] args) {
        MinhaClasseAmiga obj = new MinhaClasseAmiga();
        obj.saudacao();  // Funciona normalmente
    }
}

<strong>Exemplo em outro pacote:</strong>
// Isso causar√° erro de compila√ß√£o
import outro.pacote.MinhaClasseAmiga;

public class OutroTeste {
    public static void main(String[] args) {
        MinhaClasseAmiga obj = new MinhaClasseAmiga(); // Erro
    }
}

<strong>Uso comum:</strong> Classes friendly s√£o √∫teis para 
encapsular funcionalidades internas que 
n√£o devem ser expostas para outros pacotes.
</code>
        </pre>
      </div>
      
      <div class="block" data-tags="java-classes">
        <div class="title">Classe final</div>
        <pre>
<code>
<strong>final:</strong> Uma classe declarada com o modificador 
<code>final</code> n√£o pode ser estendida. Isso significa 
que nenhuma outra classe poder√° herdar dela.

<strong>Comportamento:</strong>
- Pode ser instanciada normalmente.
- N√£o pode servir de superclasse para outras 
classes.

<strong>Exemplo:</strong>

// Arquivo: Utilidade.java
public final class Utilidade {
    public static void imprimir(String texto) {
        System.out.println(texto);
    }
}

// Tentando estender a classe final (causar√° erro)
public class MinhaUtilidade extends Utilidade {  // ERRO!
    // N√£o √© poss√≠vel herdar de uma classe final
}

<strong>Uso comum:</strong>
- Quando se quer garantir que a implementa√ß√£o 
  da classe n√£o ser√° alterada por heran√ßa.
- Muito usado em classes utilit√°rias (como <code>java.lang.Math</code> ou <code>java.lang.String</code>).

<strong>Observa√ß√£o:</strong>
- Embora a classe n√£o possa ser estendida, 
  seus m√©todos ainda podem ser sobrecarregados 
  (overload) dentro da pr√≥pria classe, 
  se houver necessidade.
</code>
        </pre>
      </div>
     
      <div class="block" data-tags="java-classes">
        <div class="title">Classe abstract</div>
        <pre>
<code>
<strong>abstract:</strong> Uma classe abstrata serve como modelo 
para outras classes. Ela pode conter m√©todos 
com ou sem implementa√ß√£o.

<strong>Comportamento:</strong>
- N√£o pode ser instanciada diretamente.
- Pode conter m√©todos abstratos (sem corpo).
- Deve ser estendida por outra classe que 
  implemente os m√©todos abstratos.

<strong>Exemplo:</strong>

abstract class Animal {
    // M√©todo abstrato (sem corpo)
    abstract void emitirSom();

    // M√©todo com implementa√ß√£o
    void dormir() {
        System.out.println("Dormindo...");
    }
}

// Classe concreta que estende a abstrata
class Cachorro extends Animal {
    @Override
    void emitirSom() {
        System.out.println("Latindo...");
    }
}

public class Main {
    public static void main(String[] args) {
        // Animal a = new Animal(); // ERRO! Classe abstrata n√£o pode ser instanciada
        Cachorro c = new Cachorro();
        c.emitirSom();  // Latindo...
        c.dormir();     // Dormindo...
    }
}

<strong>Uso comum:</strong>
- Definir estruturas e comportamentos que devem 
  ser implementados pelas subclasses.
- Fornecer m√©todos utilit√°rios ou comuns com 
  implementa√ß√£o padr√£o.

<strong>Observa√ß√£o:</strong>
- Uma classe abstrata pode conter atributos,
  construtores e m√©todos concretos (com corpo).
- Pode ou n√£o ter m√©todos abstratos.
</code>
        </pre>
      </div>

      <div class="block" data-tags="java-classes">
        <div class="title">Classe sealed</div>
        <pre>
<code>
<strong>sealed:</strong> Uma classe sealed (selada) permite 
controlar quais outras classes podem estend√™-la.

<strong>Comportamento:</strong>
- Define explicitamente quem pode estender a 
classe.
- Introduzido no Java 15 como preview, e
  estabilizado no Java 17.

<strong>Palavras-chave:</strong>
- <em>sealed</em> ‚Üí indica que a classe √© selada.
- <em>permits</em> ‚Üí define as classes que podem 
estend√™-la.
- <em>non-sealed</em> ‚Üí uma subclasse que remove 
a restri√ß√£o.
- <em>final</em> ‚Üí subclasse que n√£o pode ser 
estendida.
- <em>sealed</em> ‚Üí subclasse que tamb√©m restringe 
quem pode estend√™-la.

<strong>Exemplo:</strong>

public sealed class Forma permits Circulo, Retangulo { }

public final class Circulo extends Forma {
    // n√£o pode ser estendida
}

public non-sealed class Retangulo extends Forma {
    // pode ser estendida por outras classes
}

<strong>Vantagens:</strong>
- Maior controle da hierarquia de classes.
- Seguran√ßa e previsibilidade ao modelar APIs.
- Ajuda o compilador e ferramentas est√°ticas a 
entender o modelo de heran√ßa.

<strong>Regras:</strong>
- Todas as subclasses devem estar no mesmo 
arquivo ou ser compiladas juntas.
- Cada subclasse deve declarar se √© sealed, 
non-sealed ou final.

</code>
        </pre>
      </div>
      <h2 class="section-title">üìò Tipos de M√©todos</h2>      
      
      <div class="block" data-tags="metodo-instancia">
        <div class="title">M√©todo de Inst√¢ncia</div>
        <pre>
<code>
class Pessoa {
  void falar() {
    System.out.println("Ol√°!");
  }
}

Pessoa p = new Pessoa();
p.falar();  // Ol√°!  
</code>
        </pre>
      </div>

      <div class="block" data-tags="metodo-estatico">
        <div class="title">M√©todo Est√°tico</div>
        <pre>
<code>
- Pode ser chamado sem instanciar a classe.

class Util {
    static int somar(int a, int b) {
        return a + b;
    }
}

int resultado = Util.somar(2, 3);  // 5  
</code>
        </pre>
      </div>

      <div class="block" data-tags="metodo-abstrato">
        <div class="title">M√©todo Abstrato</div>
        <pre>
<code>
- Declarado em classes abstratas. Sem corpo.
- Deve ser implementado por subclasses.

abstract class Animal {
    abstract void emitirSom();
}

class Gato extends Animal {
    void emitirSom() {
        System.out.println("Miau");
    }
}  
</code>
        </pre>
      </div>

      <div class="block" data-tags="metodo-final">
        <div class="title">M√©todo final</div>
        <pre>
<code>
- N√£o pode ser sobrescrito por subclasses.

class Pai {
    final void metodoImportante() {
        System.out.println("Importante!");
    }
}

class Filho extends Pai {
    // void metodoImportante() {} // ERRO!
}  
</code>
        </pre>
      </div>

      <div class="block" data-tags="metodo-sobrecarga">
        <div class="title">M√©todo Sobrecarga</div>
        <pre>
<code>
- V√°rios m√©todos com o mesmo nome, 
mas assinaturas diferentes.

class Calculadora {
    int somar(int a, int b) {
        return a + b;
    }

    double somar(double a, double b) {
        return a + b;
    }
}  
</code>
        </pre>
      </div>

      <div class="block" data-tags="metodo-sobrescrito">
        <div class="title">M√©todo Sobrescrito</div>
        <pre>
<code>
- Substitui o comportamento de um 
m√©todo herdado.

class Animal {
    void emitirSom() {
        System.out.println("Som");
    }
}

class Cachorro extends Animal {
    @Override
    void emitirSom() {
        System.out.println("Latido");
    }
}  
</code>
        </pre>
      </div>

      <div class="block" data-tags="metodo-privado">
        <div class="title">M√©todo Privado</div>
        <pre>
<code>
- S√≥ pode ser chamado dentro da pr√≥pria classe.

class Exemplo {
    private void metodoInterno() {
        System.out.println("Privado");
    }
}
</code>
        </pre>
      </div>

      <div class="block" data-tags="metodo-default">
        <div class="title">M√©todo Default em Interfaces</div>
        <pre>
<code>
- Introduzido no Java 8, permite que 
interfaces forne√ßam implementa√ß√µes padr√£o 
para m√©todos.
- Um m√©todo default tem um corpo e 
pode ser sobrescrito.

interface Animal {
  default void emitirSom() {
      System.out.println("Som gen√©rico");
  }
}

class Cachorro implements Animal {
  @Override
  public void emitirSom() {
      System.out.println("Latido");
  }
}  
</code>
        </pre>
      </div>

      <div class="block" data-tags="metodo varargd">
        <div class="title">M√©todo Varargs</div>
        <pre>
<code>
- Permite passar um n√∫mero vari√°vel de 
argumentos para o m√©todo.

class Matematica {
    void somar(int... numeros) {
        int soma = 0;
        for (int numero : numeros) {
            soma += numero;
        }
        System.out.println("Soma: " + soma);
    }
}

Matematica m = new Matematica();
m.somar(1, 2, 3, 4);  // Soma: 10
</code>
        </pre>
      </div>

      <h2 class="section-title">üìò Generics</h2>

      <div class="block" data-tags="classe-generica">
        <div class="title">Classe Gen√©rica</div>
        <pre>
<code>
public class Caixa<T> {
  private T valor;

  public void guardar(T valor) {
      this.valor = valor;
  }

  public T abrir() {
      return valor;
  }
}

<strong>Como usar:</strong>

Caixa<String> caixaDeTexto = new Caixa<>();
caixaDeTexto.guardar("Oi!");
System.out.println(caixaDeTexto.abrir()); // Oi!

Caixa<Integer> caixaDeNumero = new Caixa<>();
caixaDeNumero.guardar(42);
System.out.println(caixaDeNumero.abrir()); // 42
  
</code>
        </pre>
      </div>

      <div class="block" data-tags="metodo-generico">
        <div class="title">M√©todo Gen√©rico</div>
        <pre>
<code>
public class Util {
  public static <T> void imprimir(T elemento) {
      System.out.println(
        "Elemento: " + elemento);
  }
}

Util.imprimir("Java");
Util.imprimir(123);
Util.imprimir(3.14);
</code>
        </pre>
      </div>

      <div class="block" data-tags="multiplos tipos">
        <div class="title">M√∫ltiplos Tipos</div>
        <pre>
<code>
public class Par<A, B> {
  private A primeiro;
  private B segundo;

  public Par(A primeiro, B segundo) {
      this.primeiro = primeiro;
      this.segundo = segundo;
  }

  public A getPrimeiro() {
      return primeiro;
  }

  public B getSegundo() {
      return segundo;
  }
}

Par<String, Integer> nomeIdade = new Par<>("Maria", 30);
System.out.println(nomeIdade.getPrimeiro()); // Maria
System.out.println(nomeIdade.getSegundo());  // 30
</code>
        </pre>
      </div>

      <div class="block" data-tags="tipo-desconhecido">
        <div class="title">Tipos desconhecidos</div>
        <pre>
<code>
public void imprimirLista(List<?> lista) {
  for (Object item : lista) {
      System.out.println(item);
  }
}
</code>
        </pre>
      </div>

      <h2 class="section-title">üìò Optional</h2>

      <div class="block" data-tags="java-optional">
        <div class="title">Optional</div>
        <pre>
<code>
<strong>O que √© Optional?</strong>

Optional&lt;T&gt; √© uma classe cont√™iner introduzida 
no Java 8 para representar um valor que pode ou 
n√£o estar presente. Ela ajuda a evitar 
NullPointerException e torna o c√≥digo
mais limpo e expressivo.

<strong>Criando um Optional</strong>

Optional&lt;String&gt; nome = Optional.of("Jo√£o");
Optional&lt;String&gt; vazio = Optional.empty();
Optional&lt;String&gt; nomeSeguro = Optional.ofNullable(null);

<strong>Verificando se h√° valor</strong>

if (nome.isPresent()) {
    System.out.println("Nome: " + nome.get());
}

<strong>Usando ifPresent</strong>

nome.ifPresent(
  valor -> System.out.println("Nome: " + valor));

<strong>Usando orElse e orElseGet</strong>

String resultado = nome.orElse("Valor padr√£o");
String resultado2 = vazio.orElseGet(() -&gt; "Gerado dinamicamente");

<strong>Lan√ßando exce√ß√£o se vazio</strong>

String resultado3 = nome.orElseThrow(() -&gt; 
    new RuntimeException("Nome ausente"));

<strong>Transformando com map e flatMap</strong>

Optional&lt;String&gt; nomeMaiusculo = nome.map(
  String::toUpperCase);

Optional&lt;String&gt; resultadoCorreto = 
    nome.flatMap(n -&gt; Optional.of(n.toUpperCase()));

<strong>Combinando com Stream</strong>

Optional&lt;String&gt; encontrado = 
    Stream.of("java", "spring", "hibernate")
          .filter(p -&gt; p.startsWith("s"))
          .findFirst();

encontrado.ifPresent(System.out::println); // spring
</code>
        </pre>
      </div>

      <h2 class="section-title">üìò Record</h2>

      <div class="block" data-tags="java-record">
        <div class="title">Record</div>
        <pre>
<code>
<strong>O que √© um Record?</strong>

Record √© um tipo especial de classe introduzido no Java 14 
(com suporte definitivo no Java 16) que serve para declarar 
classes imut√°veis de forma concisa, principalmente para 
representar "data carriers" (portadores de dados).

<strong>Principais caracter√≠sticas</strong>
- Imutabilidade por padr√£o.
- Gera√ß√£o autom√°tica de construtor, getters, equals, hashCode e toString.
- Sintaxe simples e limpa.
- Ideal para DTOs e objetos de valor.

<strong>Exemplo de uso</strong>

public record Pessoa(String nome, int idade) {}

<strong>Instanciando um record</strong>

Pessoa pessoa = new Pessoa("Maria", 30);
System.out.println(pessoa.nome()); // Maria
System.out.println(pessoa.idade()); // 30

<strong>Comparando records</strong>

Pessoa p1 = new Pessoa("Jo√£o", 25);
Pessoa p2 = new Pessoa("Jo√£o", 25);
System.out.println(p1.equals(p2)); // true

<strong>Customizando o construtor</strong>

public record Produto(String nome, double preco) {
    public Produto {
        if (preco &lt; 0) {
            throw new IllegalArgumentException("Pre√ßo n√£o pode ser negativo");
        }
    }
}

<strong>Vantagens</strong>
- Redu√ß√£o de boilerplate.
- Foco em dados e n√£o em comportamento.
- Segue os princ√≠pios de orienta√ß√£o a objetos modernos.

<strong>Limita√ß√µes</strong>
- N√£o pode estender outras classes.
- N√£o pode ser mut√°vel.
- Pode implementar interfaces, mas n√£o herdar de outra classe.
</code>
        </pre>
      </div>
      
      <h2 class="section-title">üìò Spring Boot</h2>

      <div class="block wide" data-tags="spring-annotations">
        <div class="title">Annotations</div>
        <div class="code-container">
          <table>
            <thead>
              <tr>
                <th>Anota√ß√£o</th>
                <th>Descri√ß√£o</th>
                <th>Quando usar</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>@RestController</td>
                <td>Combina @Controller e @ResponseBody para APIs REST</td>
                <td>Quando criar controladores que retornam JSON/XML</td>
              </tr>
              <tr>
                <td>@RequestMapping</td>
                <td>Mapeia requisi√ß√µes HTTP para m√©todos ou classes</td>
                <td>Quando quiser configurar rotas com m√©todos HTTP espec√≠ficos</td>
              </tr>
              <tr>
                <td>@GetMapping / @PostMapping / @PutMapping / @DeleteMapping</td>
                <td>Mapeiam m√©todos HTTP GET, POST, PUT e DELETE</td>
                <td>Quando criar rotas REST de forma mais declarativa</td>
              </tr>
              <tr>
                <td>@RequestParam</td>
                <td>Obt√©m par√¢metros da URL (query string)</td>
                <td>Quando quiser capturar dados enviados na URL, como filtros ou pagina√ß√£o</td>
              </tr>
              <tr>
                <td>@PathVariable</td>
                <td>Obt√©m vari√°veis do caminho da URL</td>
                <td>Quando capturar partes din√¢micas da rota, como /produtos/{id}</td>
              </tr>
              <tr>
                <td>@RequestBody</td>
                <td>Converte o corpo da requisi√ß√£o JSON em objeto Java</td>
                <td>Quando receber dados estruturados via POST/PUT (como objetos)</td>
              </tr>
              <tr>
                <td>@ResponseBody</td>
                <td>Indica que o retorno deve ser convertido em JSON/XML</td>
                <td>Quando quiser retornar dados em vez de renderizar views</td>
              </tr>
              <tr>
                <td>@Autowired</td>
                <td>Injeta depend√™ncias automaticamente</td>
                <td>Quando precisar usar um bean gerenciado pelo Spring</td>
              </tr>
              <tr>
                <td>@Component / @Service / @Repository</td>
                <td>Define classes como beans gerenciados pelo Spring</td>
                <td>Quando quiser que o Spring instancie e gerencie suas classes</td>
              </tr>
              <tr>
                <td>@Configuration</td>
                <td>Indica que a classe cont√©m defini√ß√µes de beans</td>
                <td>Quando configurar beans manualmente via Java</td>
              </tr>
              <tr>
                <td>@Bean</td>
                <td>Cria e registra manualmente um bean no contexto</td>
                <td>Quando n√£o puder usar @Component ou precisar de controle de inst√¢ncia</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>                    
      
      <h2 class="section-title">üìò Controller</h2>

      <div class="block" data-tags="java-controller">
        <div class="title">Controller</div>
        <pre>
<code>
@RestController
@RequestMapping("/produtos")
public class ProdutoController {

  // GET /produtos
  @GetMapping
  public List<Produto> listarProdutos() {
    //implementa√ß√£o
  }

  // GET /produtos/{id}
  @GetMapping("/{id}")
  public Produto buscarPorId(@PathVariable int id) {
    //implementa√ß√£o
  }

  // POST /produtos
  @PostMapping
  public Produto adicionarProduto(@RequestBody Produto produto) {
    //implementa√ß√£o
  }

  // PUT /produtos/{id}
  @PutMapping("/{id}")
  public Produto atualizarProduto(@PathVariable int id, @RequestBody Produto atualizado) {
    //implementa√ß√£o
  }

  // DELETE /produtos/{id}
  @DeleteMapping("/{id}")
  public void removerProduto(@PathVariable int id) {
      //implementa√ß√£o
  }
}
</code>
        </pre>
      </div>

      <div class="block" data-tags="spring-controller-annotations">
        <div class="title">Anota√ß√µes do Controller</div>
        <pre>
<code>
<strong>@RestController</strong>
Combina <code>@Controller</code> e <code>@ResponseBody</code>, indicando que a classe ser√° um controller onde cada m√©todo retorna diretamente um objeto, e n√£o uma view.

<strong>Quando usar:</strong>
Classes que manipulam requisi√ß√µes REST e retornam JSON ou XML.

<strong>@RequestMapping</strong>
Define a rota base para todos os m√©todos da classe ou um endpoint espec√≠fico.

<strong>Quando usar:</strong>
Quando quiser definir a URL base de um grupo de endpoints ou configurar o m√©todo HTTP manualmente.

<strong>@GetMapping</strong>
Mapeia requisi√ß√µes HTTP GET para um m√©todo espec√≠fico.

<strong>Quando usar:</strong>
Para recuperar dados.

<strong>@PostMapping</strong>
Mapeia requisi√ß√µes HTTP POST para um m√©todo.

<strong>Quando usar:</strong>
Para cria√ß√£o de novos recursos.

<strong>@PutMapping</strong>
Mapeia requisi√ß√µes HTTP PUT para um m√©todo.

<strong>Quando usar:</strong>
Para atualizar recursos existentes.

<strong>@DeleteMapping</strong>
Mapeia requisi√ß√µes HTTP DELETE para um m√©todo.

<strong>Quando usar:</strong>
Para excluir recursos.

<strong>@PathVariable</strong>
Extrai valores diretamente da URL e os injeta como argumentos do m√©todo.

<strong>Quando usar:</strong>
Quando parte da informa√ß√£o vem do caminho da URL (ex: /produtos/10).

<strong>@RequestBody</strong>
Converte o corpo da requisi√ß√£o (geralmente JSON) em um objeto Java.

<strong>Quando usar:</strong>
Quando precisa receber dados complexos via POST ou PUT no corpo da requisi√ß√£o.

<strong>@RequestParam</strong>
Extrai valores de par√¢metros de consulta (query params) da URL.

<strong>Quando usar:</strong>
Quando os dados s√£o passados como <code>?nome=valor</code> na URL.
</code>
        </pre>
      </div>

      <div class="block" data-tags="spring-responseentity">
        <div class="title">ResponseEntity</div>
        <pre>
<code>
<strong>O que √© o ResponseEntity?</strong>
O <code>ResponseEntity</code> √© uma classe do Spring usada para representar uma resposta HTTP completa. Ela permite configurar o corpo da resposta, os cabe√ßalhos HTTP e o status da resposta de maneira flex√≠vel.

<strong>Principais caracter√≠sticas</strong>
- Permite personalizar completamente a resposta HTTP, incluindo o status, cabe√ßalhos e corpo.
- Usado frequentemente em controladores REST para retornar respostas com informa√ß√µes sobre o status da opera√ß√£o.
- Ideal para cen√°rios onde voc√™ precisa de controle total sobre a resposta.

<strong>Exemplo de uso</strong>

<code>
@GetMapping("/produto/{id}")
public ResponseEntity<Produto> getProduto(@PathVariable Long id) {
    Produto produto = produtoService.findById(id);
    if (produto != null) {
        return ResponseEntity.ok(produto);  // 200 OK
    } else {
        return ResponseEntity.notFound().build();  // 404 Not Found
    }
}
</code>

<strong>Retornando diferentes c√≥digos de status</strong>

<code>
public ResponseEntity<String> criarProduto(@RequestBody Produto produto) {
    if (produto.getPreco() <= 0) {
        return ResponseEntity.badRequest().body("Pre√ßo inv√°lido");  // 400 Bad Request
    }
    produtoService.salvar(produto);
    return ResponseEntity.status(HttpStatus.CREATED).body("Produto criado com sucesso");  // 201 Created
}
</code>

<strong>Configurando cabe√ßalhos HTTP</strong>

<code>
public ResponseEntity<Produto> getProdutoComHeaders(@PathVariable Long id) {
    Produto produto = produtoService.findById(id);
    if (produto != null) {
        return ResponseEntity.ok()
            .header("X-Custom-Header", "ValorExemplo")
            .body(produto);  // 200 OK com cabe√ßalho customizado
    } else {
        return ResponseEntity.notFound().build();  // 404 Not Found
    }
}
</code>

<strong>Vantagens</strong>
- Total controle sobre a resposta HTTP.
- Permite definir o c√≥digo de status, cabe√ßalhos e corpo de maneira flex√≠vel.
- Facilita o tratamento de diferentes cen√°rios de resposta, como erros ou sucessos.

<strong>Quando usar:</strong>
- Quando voc√™ precisar de um controle mais detalhado sobre a resposta HTTP.
- Em APIs RESTful para retornar respostas com status HTTP adequado.
- Para incluir cabe√ßalhos HTTP customizados na resposta.
</code>
        </pre>
      </div>
      
      <div class="block" data-tags="spring-valid">
        <div class="title">@Valid</div>
        <pre>
<code>
<strong>O que √© o @Valid?</strong>
A anota√ß√£o <code>@Valid</code> √© utilizada no Spring para indicar que a valida√ß√£o de um objeto deve ser executada automaticamente, com base nas anota√ß√µes de valida√ß√£o presentes nas propriedades do objeto. Ela √© comumente usada em m√©todos de controladores para validar dados recebidos em uma requisi√ß√£o HTTP antes de serem processados.

<strong>Principais caracter√≠sticas</strong>
- A anota√ß√£o √© usada em par√¢metros de m√©todos ou campos para indicar que devem ser validados.
- Funciona em conjunto com as anota√ß√µes de valida√ß√£o, como <code>@NotNull</code>, <code>@Size</code>, <code>@Email</code>, entre outras.
- O Spring realiza a valida√ß√£o de forma autom√°tica quando a anota√ß√£o <code>@Valid</code> √© aplicada.

<strong>Exemplo de uso no Controller</strong>

<code>
@PostMapping("/usuario")
public ResponseEntity<String> criarUsuario(@RequestBody @Valid Usuario usuario, BindingResult result) {
    if (result.hasErrors()) {
        return ResponseEntity.badRequest().body("Erro de valida√ß√£o");
    }
    usuarioService.salvar(usuario);
    return ResponseEntity.status(HttpStatus.CREATED).body("Usu√°rio criado com sucesso");
}
</code>

<strong>Exemplo de um DTO com valida√ß√µes</strong>

<code>
public class Usuario {

    @NotNull(message = "O nome √© obrigat√≥rio")
    @Size(min = 2, message = "O nome deve ter pelo menos 2 caracteres")
    private String nome;

    @Email(message = "O email deve ser v√°lido")
    @NotNull(message = "O email √© obrigat√≥rio")
    private String email;

    @NotNull(message = "A idade √© obrigat√≥ria")
    @Min(value = 18, message = "A idade m√≠nima √© 18 anos")
    private Integer idade;

    // Getters e Setters
}
</code>

<strong>Como funciona:</strong>
1. Quando um m√©todo de controlador recebe um objeto anotado com <code>@Valid</code>, o Spring automaticamente valida esse objeto antes de continuar com a execu√ß√£o do m√©todo.
2. Se houver erros de valida√ß√£o, eles podem ser capturados atrav√©s do par√¢metro <code>BindingResult</code> para tratamento personalizado.

<strong>Vantagens</strong>
- Facilita a valida√ß√£o de dados de entrada com anota√ß√µes de valida√ß√£o.
- Valida√ß√£o autom√°tica sem a necessidade de escrever c√≥digo adicional para verificar cada campo manualmente.
- Integra-se facilmente ao Spring MVC e Spring Boot, tornando a valida√ß√£o de objetos no controlador mais simples.

<strong>Quando usar:</strong>
- Quando voc√™ precisa validar dados de entrada de uma requisi√ß√£o HTTP (por exemplo, par√¢metros de um <code>POST</code> ou <code>PUT</code>).
- Quando estiver utilizando objetos como DTOs (Data Transfer Objects) que cont√™m dados a serem validados antes de serem processados ou persistidos.
- Para garantir que os dados estejam no formato correto, evitando erros antes da execu√ß√£o da l√≥gica do neg√≥cio.

<strong>Exemplo de erro de valida√ß√£o:</strong>
Se um usu√°rio enviar dados inv√°lidos, como um nome com menos de 2 caracteres ou um e-mail inv√°lido, o Spring retornar√° uma resposta com erro 400 (Bad Request), indicando o motivo da falha na valida√ß√£o.
</code>
        </pre>
      </div>
      <div class="block" data-tags="exception-handler">
        <div class="title">Exception Handler</div>
        <pre>
<code>
<strong>Controller</strong>
Controller criado para receber as requisi√ß√µes
@Valid em cima do @RequestBody => isso ativa a valida√ß√£o autom√°tica!
Se a requisi√ß√£o vier inv√°lida, vai estourar uma exce√ß√£o chamada 
MethodArgumentNotValidException

@PostMapping
public String createUser(@RequestBody @Valid UserRequest request) {
    return "User created successfully: " + request.getName();
}

<strong>UserRequest</strong>
Classe criada para fazer a valida√ß√£o automatica do request
public class UserRequest {
  @NotBlank(message = "Name is mandatory")
  private String name;
}

<strong>ApiException</strong>
public class ApiException extends RuntimeException {

  public ApiException(String message) {
      super(message);
  }

  public ApiException(String message, Throwable cause) {
      super(message, cause);
  }
}

<strong>ResourceNotFoundException</strong>
Se quiser mais exce√ß√µes espec√≠ficas, √© s√≥ ir criando herdando de ApiException
public class ResourceNotFoundException extends ApiException {

  public ResourceNotFoundException(String message) {
      super(message);
  }
}

<strong>ErrorResponse</strong>
Classe Criada para padronizar o retorno do erro
import java.time.LocalDateTime;

public class ErrorResponse {

  private LocalDateTime timestamp;
  private int status;
  private String error;
  private String message;
  private String path;

  public ErrorResponse(LocalDateTime timestamp, int status, String error, String message, String path) {
    this.timestamp = timestamp;
    this.status = status;
    this.error = error;
    this.message = message;
    this.path = path;
  }

  public LocalDateTime getTimestamp() {
    return timestamp;
  }

  public int getStatus() {
    return status;
  }

  public String getError() {
    return error;
  }

  public String getMessage() {
    return message;
  }

  public String getPath() {
    return path;
  }
}
</code>
        </pre>
      </div>
      
      <div class="block" data-tags="exception-handler">
        <div class="title">Exception Handler parte2</div>
        <pre>
<code>
import java.time.LocalDateTime;
import java.util.stream.Collectors;

@RestControllerAdvice
public class GlobalExceptionHandler {

  @ExceptionHandler(ApiException.class)
  public ResponseEntity<ErrorResponse> handleApiException(ApiException ex, HttpServletRequest request) {
      ErrorResponse error = new ErrorResponse(
              LocalDateTime.now(),
              HttpStatus.BAD_REQUEST.value(),
              HttpStatus.BAD_REQUEST.getReasonPhrase(),
              ex.getMessage(),
              request.getRequestURI()
      );
      return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
  }

  @ExceptionHandler(MethodArgumentNotValidException.class)
  public ResponseEntity<ErrorResponse> handleValidationException(MethodArgumentNotValidException ex, HttpServletRequest request) {
      String errors = ex.getBindingResult()
                        .getFieldErrors()
                        .stream()
                        .map(fieldError -> fieldError.getField() + ": " + fieldError.getDefaultMessage())
                        .collect(Collectors.joining("; "));

      ErrorResponse error = new ErrorResponse(
              LocalDateTime.now(),
              HttpStatus.BAD_REQUEST.value(),
              HttpStatus.BAD_REQUEST.getReasonPhrase(),
              errors,
              request.getRequestURI()
      );

      return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
  }

  @ExceptionHandler(Exception.class)
  public ResponseEntity<ErrorResponse> handleGenericException(Exception ex, HttpServletRequest request) {
      ErrorResponse error = new ErrorResponse(
              LocalDateTime.now(),
              HttpStatus.INTERNAL_SERVER_ERROR.value(),
              HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase(),
              ex.getMessage(),
              request.getRequestURI()
      );
      return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
  }
}  
</code>
        </pre>
      </div>
      
      <h2 class="section-title">üìò Chamadas para Outras APIs</h2>

      <div class="block" data-tags="rest-template">
        <div class="title">Rest-template</div>
        <pre>
<code>
<strong>GET Request</strong>
- getForObject(String url, Class<T> responseType)

Faz uma requisi√ß√£o GET para o URL fornecido 
e retorna a resposta como um objeto do tipo 
especificado.

String result = restTemplate.getForObject(
  "http://api.exemplo.com/endpoint", 
  String.class);

- getForObject(
  String url, Object[] uriVariables, 
Class<T> responseType)

Faz uma requisi√ß√£o GET para o URL com 
vari√°veis de URI, substituindo os 
par√¢metros na URL.

String result = restTemplate.getForObject(
  "http://api.exemplo.com/endpoint/{id}", 
  String.class, 123);

- getForEntity(String url, Class<T> responseType)
  
Faz uma requisi√ß√£o GET para o URL e retorna a 
resposta como um ResponseEntity, que inclui o 
corpo da resposta e os cabe√ßalhos HTTP.  

ResponseEntity<String> response = restTemplate
  .getForEntity(
    "http://api.exemplo.com/endpoint", 
  String.class);

</code>
        </pre>
      </div>

      <div class="block" data-tags="rest-template">
        <div class="title">Rest-template</div>
        <pre>
<code>
<strong>POST Request</strong>  
- postForObject(String url, Object request, 
Class<T> responseType)

Faz uma requisi√ß√£o POST para o URL fornecido, 
envia o objeto request como o corpo da 
requisi√ß√£o e retorna a resposta como um 
objeto do tipo especificado.  

MyRequest request = new MyRequest();
MyResponse response = restTemplate
.postForObject(
  "http://api.exemplo.com/endpoint", 
  request, 
  MyResponse.class);


- postForEntity(String url, Object request, 
Class<T> responseType)

Faz uma requisi√ß√£o POST e retorna a resposta 
como um ResponseEntity.  

MyRequest request = new MyRequest();
ResponseEntity<MyResponse> response = restTemplate
  .postForEntity(
    "http://api.exemplo.com/endpoint", 
  request, MyResponse.class);

</code>
        </pre>
      </div>

      <div class="block" data-tags="rest-template">
        <div class="title">Rest-template</div>
        <pre>
<code>
<strong>PUT Request</strong>

- put(String url, Object request)

Faz uma requisi√ß√£o PUT para o URL fornecido 
com o objeto request como o corpo 
da requisi√ß√£o. N√£o retorna valor.

MyRequest request = new MyRequest();
restTemplate.put(
  "http://api.exemplo.com/endpoint", request);

</code>
        </pre>
      </div>

      <div class="block" data-tags="rest-template">
        <div class="title">Rest-template</div>
        <pre>
<code>
<strong>DELETE Request</strong>

- delete(String url)

Faz uma requisi√ß√£o DELETE para o URL 
fornecido. N√£o retorna valor.

restTemplate.delete(
  "http://api.exemplo.com/endpoint/{id}",
   123);

- delete(String url, Object... uriVariables)

Faz uma requisi√ß√£o DELETE, substituindo os 
par√¢metros da URL com os valores fornecidos.

restTemplate.delete(
  "http://api.exemplo.com/endpoint/{id}", 
  123);

</code>
        </pre>
      </div>

      <div class="block" data-tags="rest-template">
        <div class="title">Rest-template</div>
        <pre>
<code>
<strong>Exchange Request</strong>

- exchange(
  String url, 
  HttpMethod method, 
  HttpEntity<?> requestEntity, 
  Class<T> responseType)

Executa uma requisi√ß√£o HTTP com o m√©todo 
especificado (GET, POST, PUT, DELETE, etc.), 
e retorna um ResponseEntity com o corpo e 
os cabe√ßalhos da resposta.

HttpHeaders headers = new HttpHeaders();
headers.set("Authorization", "Bearer token");
HttpEntity<String> entity = new HttpEntity<>(headers);

ResponseEntity<String> response = restTemplate.exchange(
    "http://api.exemplo.com/endpoint",
    HttpMethod.GET,
    entity,
    String.class
);

url: A URL do endpoint.
method: O m√©todo HTTP (GET, POST, PUT, DELETE, etc.).
requestEntity: O corpo e os cabe√ßalhos da requisi√ß√£o.
responseType: O tipo de resposta esperada.

RestTemplate √© bloqueante: Mesmo com essas op√ß√µes, 
o RestTemplate continua sendo um cliente bloqueante. 
Isso significa que a execu√ß√£o do c√≥digo ser√° 
interrompida at√© que a resposta da requisi√ß√£o 
seja recebida.
</code>
        </pre>
      </div>
  
      <h2 class="section-title">üìò @Async</h2>
      
      <div class="block" data-tags="async">
        <div class="title">Async</div>
        <pre>
<code>
  - Voc√™ precisa colocar a anota√ß√£o @EnableAsync 
  em uma classe de configura√ß√£o 
  (geralmente a @SpringBootApplication j√° serve):

@SpringBootApplication
@EnableAsync
public class SeuProjetoApplication {
    public static void main(String[] args) {
        SpringApplication.run(SeuProjetoApplication.class, args);
    }
}

Anotar o m√©todo que ser√° ass√≠ncrono com @Async

@Service
public class EmailService {

  @Async
  public void enviarEmail(String destinatario) {
      // Simulando tempo de envio
      System.out.println("Enviando e-mail para " + destinatario);
  }
}  
</code>
        </pre>
      </div>

      <h2 class="section-title">üìò Spring Data </h2>
       
      <div class="block" data-tags="spring-data-mysql">
        <div class="title">Spring data mysql configura√ß√£o</div>
        <pre>
<code>
<strong>1 - Adicionar dependencias</strong>
  
spring-boot-starter-data-jpa
mysql-connector-java

<strong>2 - Configurar application properties</strong>

spring.datasource.url=jdbc:mysql://localhost:3306/seu_banco_de_dados?useSSL=false&serverTimezone=UTC
spring.datasource.username=seu_usuario
spring.datasource.password=sua_senha

#para o Hibernate criar/atualizar as tabelas automaticamente
spring.jpa.hibernate.ddl-auto=update
#mostra as queries no console
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect

</code>
        </pre>
      </div>
      
       
      <div class="block" data-tags="spring-data-mysql">
        <div class="title">Spring data mysql entidade</div>
        <pre>
<code>
<strong>Entidade simples</strong>  
@Entity
@Table(name = "pessoas")
public class Pessoa {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @Column(nullable = false, length = 100)
  private String nome;

  @Column(nullable = false, length = 100, unique = true)
  private String email
}      
</code>
        </pre>
      </div>
      
      <div class="block" data-tags="spring-data-mysql">
        <div class="title">Spring data mysql entidade com chave primaria composta</div>
        <pre>
<code>
<strong>Entidade com chave primaria composta</strong>  

1. Crie a classe da chave composta

Essa classe n√£o √© uma entidade, ela apenas define a chave.
Ela precisa:
- Ser anotada com @Embeddable
- Implementar Serializable
- Ter equals e hashCode

@Embeddable
public class PessoaId implements Serializable {

  private String cpf;
  private String rg;

  @Override
    public boolean equals(Object o) {
        //implementacao
    }

    @Override
    public int hashCode() {
      //implementacao
    }
}

2. Crie a entidade usando @EmbeddedId

@Entity
@Table(name = "pessoas")
public class Pessoa {

  @EmbeddedId
  private PessoaId id;

  @Column(nullable = false)
  private String nome;

  @Column(length = 100)
  private String email;
}
</code>
        </pre>
      </div>
      
      <div class="block" data-tags="spring-data-mysql">
        <div class="title">Spring data mysql One To Many</div>
        <pre>
<code>
<strong>One To Many</strong>  

Exemplo: Pessoa ‚Üí Telefones
Uma Pessoa pode ter v√°rios Telefones.
Pessoa = 1 (um lado)
Telefone = N (muitos lados)

@Entity
@Table(name = "pessoas")
public class Pessoa {

  //cascade = CascadeType.ALL - Se salvar ou deletar Pessoa, automaticamente salva ou deleta seus Telefones.
  //orphanRemoval = true - Se remover um Telefone da lista de Pessoa, ele tamb√©m ser√° deletado do banco.
  @OneToMany(mappedBy = "pessoa", cascade = CascadeType.ALL, orphanRemoval = true)
  private List<Telefone> telefones = new ArrayList<>();

  // m√©todo utilit√°rio para adicionar telefone
  public void adicionarTelefone(Telefone telefone) {
      telefone.setPessoa(this); // seta a rela√ß√£o dos dois lados
      telefones.add(telefone);
  }  
}

@Entity
@Table(name = "telefones")
public class Telefone {

  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "pessoa_id")
  private Pessoa pessoa;
}

<strong>Como salvar uma Pessoa com v√°rios Telefones</strong>

Pessoa pessoa = new Pessoa("Maria Oliveira");
pessoa.adicionarTelefone(new Telefone("1199999-9999"));
pessoa.adicionarTelefone(new Telefone("1188888-8888"));
pessoaRepository.save(pessoa);

</code>
        </pre>
      </div>

      <div class="block" data-tags="spring-data-mysql">
        <div class="title">Spring data mysql Many To One</div>
        <pre>
<code>
<strong>Many To One</strong>

Exemplo: Telefone ‚Üí Pessoa
Cada Telefone est√° ligado a uma Pessoa (muitos telefones para uma pessoa).

@Entity
@Table(name = "telefones")
public class Telefone {
  //fetch = LAZY -> O JPA s√≥ carrega a Pessoa quando voc√™ chamar telefone.getPessoa()
  //@ManyToOne vai no lado que tem muitos registros
  @ManyToOne(fetch = FetchType.LAZY)
  //Define a FK (pessoa_id) e exige que ela seja obrigat√≥ria.
  @JoinColumn(name = "pessoa_id", nullable = false)
  private Pessoa pessoa;  
}

@Entity
@Table(name = "pessoas")
public class Pessoa {
  //Se voc√™ quiser, pode deixar a Pessoa sem a lista de Telefones tamb√©m.
}

<strong>Como salvar um telefone novo para uma pessoa j√° existente:</strong>

Pessoa pessoaExistente = pessoaRepository.findById(1L).orElseThrow();
Telefone telefone = new Telefone("1199999-9999", pessoaExistente);
telefoneRepository.save(telefone);
</code>
        </pre>
      </div>  

      <div class="block" data-tags="spring-data-mysql">
        <div class="title">Spring data mysql One To One</div>
        <pre>
<code>
<strong>One To One</strong>

Pessoa ‚Üî Documento
Cada Pessoa tem um Documento.
Cada Documento pertence a uma Pessoa.

@Entity
@Table(name = "pessoas")
public class Pessoa {
  //mappedBy sempre indica que a FK (pessoa_id) est√° no lado da outra entidade (Documento nesse caso).
  @OneToOne(mappedBy = "pessoa", cascade = CascadeType.ALL, fetch = FetchType.LAZY, optional = false)
  private Documento documento;
}

@Entity
@Table(name = "documentos")
public class Documento {
  @OneToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "pessoa_id", nullable = false, unique = true)
  private Pessoa pessoa;
}

<strong>Como salvar um Pessoa com Documento</strong>

Pessoa pessoa = new Pessoa("Jo√£o Silva");
Documento documento = new Documento("123456789");
pessoa.setDocumento(documento);
pessoaRepository.save(pessoa);
</code>
        </pre>
      </div>

      <div class="block" data-tags="spring-data-mysql">
        <div class="title">Spring data mysql Many To Many</div>
        <pre>
<code>
<strong>Many To Many</strong>

Aluno <-> Curso
Um Aluno pode fazer v√°rios Cursos.
Um Curso pode ter v√°rios Alunos.

@Entity
@Table(name = "alunos")
public class Aluno {
  @ManyToMany
    //Cria a tabela de jun√ß√£o no banco (alunos_cursos).
    @JoinTable(
        name = "alunos_cursos",
        //Qual coluna da tabela de jun√ß√£o faz refer√™ncia ao Aluno.
        joinColumns = @JoinColumn(name = "aluno_id"),
        //Qual coluna da tabela de jun√ß√£o faz refer√™ncia ao Curso.
        inverseJoinColumns = @JoinColumn(name = "curso_id")
    )
    private Set<Curso> cursos = new HashSet<>();
}

@Entity
@Table(name = "cursos")
public class Curso {
  //Diz que o lado Curso √© o lado "espelho" do relacionamento.
  @ManyToMany(mappedBy = "cursos")
  private Set<Aluno> alunos = new HashSet<>();
}

//Como salvar um aluno com cursos:

Curso curso1 = new Curso("Matem√°tica");
Curso curso2 = new Curso("Hist√≥ria");

cursoRepository.save(curso1);
cursoRepository.save(curso2);

Aluno aluno = new Aluno("Maria");
aluno.getCursos().add(curso1);
aluno.getCursos().add(curso2);

alunoRepository.save(aluno);

</code>
        </pre>
      </div>
      
      <div class="block" data-tags="java-streams">
        <div class="title">Tipos de consultas JPA</div>
        <pre>
<code>
<strong>1.1 Consultas com M√©todos Derivados</strong>

O Spring Data JPA permite que voc√™ escreva consultas apenas definindo o nome do m√©todo no reposit√≥rio.

public interface PessoaRepository extends JpaRepository<Pessoa, Long> {
  // Consultas por nome
  List<Pessoa> findByNome(String nome);

  // Consultas com filtros mais complexos
  List<Pessoa> findByIdadeGreaterThanEqual(int idade);
}

<strong>1.2 Consultas Customizadas com @Query</strong>

public interface PessoaRepository extends JpaRepository<Pessoa, Long> {

@Query("SELECT p FROM Pessoa p WHERE p.nome = :nome")
List<Pessoa> findPessoasByNome(@Param("nome") String nome);

@Query("SELECT p FROM Pessoa p WHERE p.idade > :idade")
List<Pessoa> findPessoasByIdadeMaiorQue(@Param("idade") int idade);
}

<strong>2. Criteria API com Spring Data JPA</strong>

@Repository
public class PessoaRepositoryCustomImpl implements PessoaRepositoryCustom {

    @PersistenceContext
    private EntityManager entityManager;

    @Override
    public List<Pessoa> buscarPorNome(String nome) {
        CriteriaBuilder cb = entityManager.getCriteriaBuilder();
        CriteriaQuery<Pessoa> cq = cb.createQuery(Pessoa.class);
        Root<Pessoa> root = cq.from(Pessoa.class);
        Predicate nomePredicate = cb.equal(root.get("nome"), nome);
        cq.where(nomePredicate);
        return entityManager.createQuery(cq).getResultList();
    }
}

Neste caso, a interface PessoaRepositoryCustom seria definida como:

public interface PessoaRepositoryCustom {
  List<Pessoa> buscarPorNome(String nome);
}

E a interface principal PessoaRepository ficaria assim:

public interface PessoaRepository extends JpaRepository<Pessoa, Long>, PessoaRepositoryCustom {
}

3. Named Queries com Spring Data JPA

Voc√™ pode usar Named Queries no Spring Data JPA, tanto na entidade quanto nos reposit√≥rios. 

@Entity
@NamedQuery(name = "Pessoa.findByNome", query = "SELECT p FROM Pessoa p WHERE p.nome = :nome")
public class Pessoa {
    // Campos e m√©todos
}

No reposit√≥rio, voc√™ usaria a consulta nomeada assim:

public interface PessoaRepository extends JpaRepository<Pessoa, Long> {

  @Query(name = "Pessoa.findByNome")
  List<Pessoa> findByNome(@Param("nome") String nome);
}

Ou, caso voc√™ queira usar uma consulta nomeada sem o uso de @Query no reposit√≥rio, pode invocar diretamente o m√©todo createNamedQuery na classe EntityManager.

4. Consultas Nativas SQL com Spring Data JPA

Voc√™ pode usar consultas SQL nativas no Spring Data JPA com a anota√ß√£o @Query e definindo a propriedade nativeQuery = true.

public interface PessoaRepository extends JpaRepository<Pessoa, Long> {

  @Query(value = "SELECT * FROM pessoas WHERE nome = :nome", nativeQuery = true)
  List<Pessoa> findPessoasByNome(@Param("nome") String nome);
}

Se voc√™ quiser mapear o resultado de uma consulta SQL para um tipo diferente da entidade (um DTO, por exemplo), tamb√©m pode fazer isso:

public interface PessoaRepository extends JpaRepository<Pessoa, Long> {

  @Query(value = "SELECT p.id, p.nome FROM pessoas p WHERE p.nome = :nome", nativeQuery = true)
  List<Object[]> findPessoasIdENome(@Param("nome") String nome);
}

E, em seguida, processa os resultados da consulta nativa:

List<Object[]> resultado = pessoaRepository.findPessoasIdENome("Jo√£o Silva");
for (Object[] obj : resultado) {
    Long id = (Long) obj[0];
    String nome = (String) obj[1];
    System.out.println("ID: " + id + ", Nome: " + nome);
}

5. Pagina√ß√£o com Spring Data JPA

O Spring Data JPA oferece suporte √† pagina√ß√£o de resultados por meio da interface PagingAndSortingRepository, que herda de JpaRepository.

public interface PessoaRepository extends PagingAndSortingRepository<Pessoa, Long> {

  Page<Pessoa> findByNome(String nome, Pageable pageable);
}

Ao chamar esse m√©todo, voc√™ pode passar um objeto Pageable (como o PageRequest) para controlar a p√°gina e o n√∫mero de resultados por p√°gina.

Pageable pageable = PageRequest.of(0, 10);  // Primeira p√°gina com 10 resultados
Page<Pessoa> pessoasPage = pessoaRepository.findByNome("Jo√£o Silva", pageable);

pessoasPage.getContent().forEach(p -> System.out.println(p.getNome()));

A classe Page tem m√©todos √∫teis, como getTotalElements() (para saber o total de registros) e getTotalPages() (para saber o total de p√°ginas).

6. Named Entity Graphs

O Named Entity Graph √© uma forma de definir quais associa√ß√µes de entidades devem ser carregadas em uma consulta. √â √∫til para evitar o carregamento excessivo de dados e resolver problemas de N+1 queries.

Voc√™ pode usar a anota√ß√£o @EntityGraph para definir as associa√ß√µes a serem carregadas.

@Entity
@NamedEntityGraph(name = "Pessoa.detalhada", 
                  attributeNodes = @NamedAttributeNode("endereco"))
public class Pessoa {
    @OneToOne
    private Endereco endereco;
    // Outros atributos e m√©todos
}

public interface PessoaRepository extends JpaRepository<Pessoa, Long> {

  @EntityGraph(value = "Pessoa.detalhada", type = EntityGraph.EntityGraphType.FETCH)
  List<Pessoa> findByNome(String nome);
}

Com isso, a consulta findByNome tamb√©m carrega o endereco de forma eficiente, sem precisar de uma consulta adicional.

</code>
        </pre>
      </div>

      <h2 class="section-title">üìò Spring Data MongoDb</h2>
      
      <div class="block" data-tags="spring-data-mongo">
        <div class="title">Spring Data Mongo DB - configuracao</div>
        <pre>
<code>
<strong>Adicionar Depend√™ncia</strong>  
  
spring-boot-starter-data-mongodb

<strong>Configurar a Conex√£o com o MongoDB</strong>
Assim
spring.data.mongodb.uri=mongodb://localhost:27017/minha_base
Ou 
spring.data.mongodb.host=localhost
spring.data.mongodb.port=27017
spring.data.mongodb.database=minha_base
spring.data.mongodb.username=usuario
spring.data.mongodb.password=senha
</code>
        </pre>
      </div>

      <div class="block" data-tags="spring-data-mongo">
        <div class="title">Spring Data Mongo DB</div>
        <pre>
<code>
<strong>Criar o Modelo (Entidade)</strong>  

@Document(collection = "pessoas")
public class Pessoa {

    @Id
    private String id;
    private String nome;
    private int idade;

    // Construtores, getters e setters
}

<strong>Consulta</strong>

public interface PessoaRepository extends MongoRepository<Pessoa, String> {

    // M√©todo para buscar pessoas pelo nome
    List<Pessoa> findByNome(String nome);

    // M√©todo para buscar pessoas com idade maior que o valor fornecido
    List<Pessoa> findByIdadeGreaterThan(int idade);
}

<strong>Altera√ß√£o</strong>

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class PessoaService {

    @Autowired
    private PessoaRepository pessoaRepository;

    // Atualiza os dados de uma pessoa
    public Pessoa atualizarPessoa(String id, Pessoa novaPessoa) {
        Pessoa pessoaExistente = pessoaRepository.findById(id).orElse(null);
        
        if (pessoaExistente != null) {
            pessoaExistente.setNome(novaPessoa.getNome());
            pessoaExistente.setIdade(novaPessoa.getIdade());
            return pessoaRepository.save(pessoaExistente);  // Atualiza a pessoa
        } else {
            return null;  // Caso n√£o encontre a pessoa com o ID fornecido
        }
    }
}

<strong>Exclus√£o</strong>

@Service
public class PessoaService {

    @Autowired
    private PessoaRepository pessoaRepository;

    // Excluir pessoa por ID
    public void excluirPessoa(String id) {
        pessoaRepository.deleteById(id);  // Exclui pelo ID
    }
}

Exemplo de exclus√£o de pessoa por nome:

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class PessoaService {

    @Autowired
    private PessoaRepository pessoaRepository;

    // Excluir pessoa por nome
    public void excluirPorNome(String nome) {
        List<Pessoa> pessoas = pessoaRepository.findByNome(nome);
        for (Pessoa pessoa : pessoas) {
            pessoaRepository.delete(pessoa);  // Exclui todas as pessoas com o nome especificado
        }
    }
}

<strong>Salvar</strong>

@Service
public class PessoaService {

    @Autowired
    private PessoaRepository pessoaRepository;

    // Criar nova pessoa
    public Pessoa criarPessoa(Pessoa pessoa) {
        return pessoaRepository.save(pessoa);  // Salva a pessoa no banco de dados
    }
}

</code>
        </pre>
      </div>


      <!-- 
        spring cached
        spring retry
        spring kafka
        spring web client
        
      <div class="block" data-tags="java-streams">
        <div class="title">Streams</div>
        <pre>
<code>
</code>
        </pre>
      </div>     
      -->
  </main>

  <script src="scripts.js"></script>
</body>
</html>
